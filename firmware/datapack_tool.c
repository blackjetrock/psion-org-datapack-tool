////////////////////////////////////////////////////////////////////////////////
//
// Psion Organiser Datapack Tool Control Program
//
// This is an early version of the code which is a copy
// of the pak_gadget code with enough changes to test the
// first version of the hardware wrt the display, keys and
// SD card.
//
// It does not have working datapack functionality, that has to ported from
// other datapack tool code
//
////////////////////////////////////////////////////////////////////////////////

#include <stdarg.h>
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "pico/stdlib.h"
#include "hardware/pio.h"
#include "hardware/clocks.h"
#include "pico/multicore.h"

#include "f_util.h"

#include "ff.h"
#include "ff_stdio.h"
#include "hw_config.h"
#include "my_debug.h"
#include "rtc.h"
#include "sd_card.h"

typedef uint8_t byte;
typedef uint16_t word;
typedef int boolean;


boolean paged_addr                  = true;     // true for paged addressing, false for linear addressing - note linear addressing is untested!! - paged is default
boolean datapak_mode                = true;     // true for datapaks, false for rampaks, mode can be changed by command option
boolean program_low                 = false;    // will be set true when SLOT_SPGM_PIN is low during datapak write, so page counter can be pulsed accordingly
const boolean force_write_cycles    = false;    // set true to perform max write cycles, without break for confirmed write
const boolean overwrite             = false;    // set true to add a longer overwite after confirmed write
const byte max_datapak_write_cycles = 50 ;        // max. no. of write cycle attempts before failure
const int datapak_write_pulse      = 100;      // datapak write pulse in us, 1000 us = 1 ms, 10us write can be read by Arduino, but not Psion!
word current_address                = 0;
#define max_eprom_size              0x8000      // max eprom size - 32k - only used by Matt's code

boolean read_fixed_size             = false;    // true for fixed size
//boolean read_fixed_size           = true;     // true for fixed size
word read_pack_size                 = 0x7e9b;   // set a fixed pack size for read
//word read_pack_size               = 0x0100; 

byte CLK_val                        = 0;        // flag to indicate CLK state


// Use this if breakpoints don't work
#define DEBUG_STOP {volatile int x = 1; while(x) {} }

// Are we compiling for the gadget breakout or the picopak?
#define PICOPAK 0

// Drop into a loop that displays key states and does nothing else
#define KEY_DEBUG_ONLY                0

// Interrupts may muck up the pack interface, but it does seem to run with them enabled.
// If USB is ever to work then interrupts need to be enabled.
#define NO_INTERRUPTS_WHILE_POLLING   0
#define TEST_STDIO                    0

// Redefine pins to match our hardware
// datapack tool port note:
//
// We have SD clock defined as pin 5 here, but that is wired to SW3 so
// this doesn't make sense. It does seem to work, though.
// The actual clock pin is on GPIO18, which is CMD here, so I don't know what's
// going on

#define PICO_SD_CLK_PIN        5
#define PICO_SD_CMD_PIN       18
#define PICO_SD_DAT0_PIN      19
#define ENABLE_4_PIN           0

#define SUPPORT_ID_BYTE        1
#define PAK_ID_BYTE         0x01
#define READ_ONLY              0
#define INIT_PAK_MEMORY        0
#define FF_FIRST_BYTES         0

// Direct access to GPIO registers is faster, and we need speed
#define DIRECT_GPIO            1

// Number of buttons used for the menu system. The 'exit polling' button is not in this
// list, it is coded as a GPIO line as we don't want to waste time processing the menu
// buttons in the fast polling loop

#define NUM_BUTTONS            3

// All organiser files are in this subdirectory on the SD card, just to keep things tidy
// and allow the card to be used for other things if needed.
#define PAK_DIR                "/PAK"

// Debounce
#define MAX_BUT_COUNT          6

bool sd_ok_flag = false;

// Do we use a polling loop of interrupts?
#define USE_INTERRUPTS         0
#define USE_POLLING            1

// For added speed, we poll the address counter stuff on the other core
#define MULTICORE_POLL         1

// The address into pak memory
#define PAK_ADDRESS (ss_address | ss_page)
//#define PAK_ADDRESSxxx (ss_address)

// Pack ID byte
#define PACK_ID_PAGED  0x04

// For the OLED display
const uint SDA_PIN             = 15;
const uint SCL_PIN             = 14;

#ifndef I2C_FUNCTIONS_H_
#define I2C_FUNCTIONS_H_

typedef unsigned char BYTE;

// Buttons got changed for PCB layout reasons
#if 0
const int SW0_PIN       = 0;
const int SW1_PIN       = 1;
const int SW2_PIN       = 5;
const int SW3_PIN       = 26;
#else
const int SW0_PIN       = 28;
const int SW1_PIN       = 27;
const int SW2_PIN       = 26;
//const int SW3_PIN       = 5;
#endif

const int SLOT_SPGM_PIN = 10;
const int SLOT_SS_PIN   = 11;
const int SLOT_SCLK_PIN = 12;

const int SLOT_SOE_PIN  = 9;
const int SLOT_SMR_PIN  = 8;

const int SLOT_SD0_PIN  = 0;
const int SLOT_SD1_PIN  = 1;
const int SLOT_SD2_PIN  = 2;
const int SLOT_SD3_PIN  = 3;
const int SLOT_SD4_PIN  = 4;
const int SLOT_SD5_PIN  = 5;
const int SLOT_SD6_PIN  = 6;
const int SLOT_SD7_PIN  = 7;

const byte data_pin[8] =
  {
   SLOT_SD0_PIN,
   SLOT_SD1_PIN,
   SLOT_SD2_PIN,
   SLOT_SD3_PIN,
   SLOT_SD4_PIN,
   SLOT_SD5_PIN,
   SLOT_SD6_PIN,
   SLOT_SD7_PIN
  }; // pins D0 to D7 on Datapak

const int data_gpio[8] =
  {
   SLOT_SD0_PIN,
   SLOT_SD1_PIN,
   SLOT_SD2_PIN,
   SLOT_SD3_PIN,
   SLOT_SD4_PIN,
   SLOT_SD5_PIN,
   SLOT_SD6_PIN,
   SLOT_SD7_PIN,
  };

const int LS_DIR_PIN    = 13;
const int VPP_ON_PIN    = 17;

volatile int ss_count = 0;
volatile int soe_state = 1;
volatile int ss_address = 0;
volatile int ss_page = 0;


// Memory that emulates a pak
typedef unsigned char BYTE;
typedef void (*FPTR)();
typedef void (*CMD_FPTR)(char *cmd);

// The tracing was used for low level analysis of the protocol
#define TRACE_LENGTH 2
BYTE trace0[TRACE_LENGTH];
BYTE trace1[TRACE_LENGTH];

void nextPage();

volatile int trace_i = 0;
#define TRACE0(XX) if(trace_i != (TRACE_LENGTH-1)) {trace0[trace_i++] = XX; /*trace_i %= TRACE_LENGTH;*/}
#define TRACE1(XX) if(trace_i != (TRACE_LENGTH-1)) {trace1[trace_i++] = XX; /*trace_i %= TRACE_LENGTH;*/}

//#define TRACE(XX)

//#define WRITE_TRAP if( (PAK_ADDRESS + data) == 0)  while(1);

#define WRITE_TRAP

//#define PAK_MEMORY_SIZE  65536
#define PAK_MEMORY_SIZE  (128*1024)
//#define PAK_MEMORY_SIZE  32768

// Allow a file to be selected. The file name will be stored for a later 'read' command.

int file_offset = 0;
int max_filenum = 0;

// File names for paks that are written to SD card
#define FILE_PAGE 7
#define PAK_FILE_NAME_FORMAT "pak%05d.opk"
#define PAK_FILE_NAME_GLOB   "pak*.opk"

// I2C Port descriptor
typedef struct _I2C_PORT_DESC
{
  unsigned char sdaport;
  unsigned char sdabit;
  unsigned char sclport;
  unsigned char sclbit;
} I2C_PORT_DESC;


// Slave device descriptor
typedef struct _I2C_SLAVE_DESC
{
  I2C_PORT_DESC *port;             // Port the device is on
  unsigned char slave_7bit_addr;        // SLave address
} I2C_SLAVE_DESC;


#if PICOPAK
#define MENU_MAX  3
#else
#define MENU_MAX  6
#endif

int menu_offset = 0;

typedef struct _BUTTON
{
  int     count;
  bool pressed;
  bool last_pressed;   // For edge detection
  FPTR    event_fn;
} BUTTON;

BUTTON buttons[NUM_BUTTONS];
enum ELEMENT_TYPE
  {
   BUTTON_ELEMENT = 10,
   SUB_MENU,
   MENU_END,
  };

struct MENU_ELEMENT
{
  enum ELEMENT_TYPE type;
  char *text;
  const void *submenu;
  void (*function)(struct MENU_ELEMENT *e);
};

void button_display(struct MENU_ELEMENT *e);
void button_list(struct MENU_ELEMENT *e);
void button_pak_id(struct MENU_ELEMENT *e);
void button_pak_hdr(struct MENU_ELEMENT *e);
void button_blank(struct MENU_ELEMENT *e);

//void but_ev_file_up();
//void but_ev_file_down();
void but_ev_file_select();

#define REAL_US_DELAYS 1

#if REAL_US_DELAYS

void loop_delay(int delay)
{
  sleep_us(delay);
}

#else

void loop_delay(int delay)
{
  volatile x, y;

  for(x=0; x<delay; x++)
    {
      for(y=0; y<10; y++)
	{
	}
    }
}

#endif

int menuloop_done = 0;

////////////////////////////////////////////////////////////////////////////////
//
// Prototypes
//
////////////////////////////////////////////////////////////////////////////////

word read_dir(void);
void write_opk_file(I2C_SLAVE_DESC *slave, char *filename);
void read_opk_file(I2C_SLAVE_DESC *slave, char *filename);
void button_compare_file(struct MENU_ELEMENT *e);
void compare_opk_file(I2C_SLAVE_DESC *slave, char *filename);
byte readByte();
int cd_to_pak_dir(I2C_SLAVE_DESC *slave);
void auto_size(int oled_nserial);
void ArdDataPinsToOutput();
void packOutputAndSelect();
void packDeselectAndInput();
byte readByte();
void ArdDataPinsToInput(void);
void nextAddress();
void resetAddrCounter();

////////////////////////////////////////////////////////////////////////////////

#if !INIT_PAK_MEMORY
BYTE pak_memory[PAK_MEMORY_SIZE];
#else

// Complete 'angling' pack embedded in flash. It is probably possible to store
// every known pack in SPI flash and not use the SD card at all. Obviously with no
// SD card there's no saving of packs, though.

BYTE pak_memory[PAK_MEMORY_SIZE] =
  {
   0x78,0x04,0x56,0x00,0x03,0x02,0x35,0x46,0x06,0x4c,
   0x09,0x81,0x4d,0x41,0x49,0x4e,0x20,0x20,0x20,0x20,0x90,0x09,0x83,0x46,0x49,0x53,
   0x48,0x20,0x20,0x20,0x20,0x00,0x02,0x80,0x01,0x26,0x01,0x22,0x00,0x29,0x00,0xfc,
   0x00,0x00,0x13,0x02,0x59,0x25,0x00,0xff,0xe9,0x03,0x44,0x52,0x24,0x02,0xff,0xe6,
   0x02,0x46,0x24,0x02,0xff,0xdc,0x00,0x00,0x00,0x06,0xff,0xe5,0x02,0xff,0xdb,0x08,
   0x00,0x00,0x0f,0xff,0xdc,0x24,0x04,0x46,0x49,0x53,0x48,0x20,0x02,0x20,0x01,0x7d,
   0x06,0x45,0x58,0x49,0x53,0x54,0x24,0x81,0x02,0xff,0xdc,0x24,0x00,0x4a,0x7e,0x00,
   0x32,0x0d,0xff,0xd9,0x24,0x10,0x43,0x52,0x45,0x41,0x54,0x45,0x2d,0x46,0x49,0x4c,
   0x45,0x2c,0x51,0x55,0x49,0x54,0x98,0x7f,0x00,0xff,0xd9,0x022,0x00,0x01,0x2c,0x7e,
   0x00,0x10,0x20,0x00,0x7d,0x06,0x46,0x49,0x53,0x48,0x43,0x52,0x84,0x51,0x00,0x03,
   0x7b,0x20,0x00,0x7d,0x06,0x46,0x49,0x53,0x48,0x4f,0x50,0x84,0x20,0x00,0x7d,0x06,
   0x4d,0x41,0x44,0x55,0x44,0x47,0x84,0x0d,0xff,0xd7,0x24,0x20,0x41,0x44,0x44,0x2d,
   0x4e,0x45,0x57,0x2d,0x46,0x49,0x53,0x48,0x2c,0x53,0x45,0x41,0x52,0x43,0x48,0x2c,
   0x52,0x45,0x50,0x4f,0x52,0x54,0x2c,0x55,0x54,0x49,0x4c,0x53,0x98,0x7f,0x00,0xff,
   0xd7,0x22,0x00,0x01,0x2c,0x7e,0x00,0x14,0x20,0x00,0x7d,0x07,0x46,0x49,0x53,0x48,
   0x41,0x44,0x44,0x84,0x51,0xff,0xc2,0x51,0x00,0x55,0x00,0xff,0xd7,0x22,0x00,0x02,
   0x2c,0x7e,0x00,0x14,0x20,0x00,0x7d,0x07,0x46,0x49,0x53,0x48,0x53,0x45,0x45,0x84,
   0x51,0xff,0xa6,0x51,0x00,0x39,0x00,0xff,0xd7,0x22,0x00,0x03,0x2c,0x7e,0x00,0x14,
   0x20,0x00,0x7d,0x07,0x46,0x49,0x53,0x48,0x52,0x45,0x50,0x84,0x51,0xff,0x8a,0x51,
   0x00,0x1d,0x00,0xff,0xd7,0x22,0x00,0x04,0x2c,0x7e,0x00,0x12,0x20,0x00,0x7d,0x05,
   0x55,0x54,0x49,0x4c,0x53,0x84,0x51,0xff,0x70,0x51,0x00,0x03,0x7b,0x7b,0x00,0x00,
   0x09,0x83,0x46,0x49,0x53,0x48,0x41,0x44,0x44,0x20,0x00,0x02,0x80,0x06,0x11,0x06,
   0x0d,0x00,0x3a,0x05,0xee,0x00,0x00,0x00,0x00,0x00,0x00,0x12,0xff,0xf4,0x06,0xff,
   0xe6,0x04,0xff,0xe2,0x02,0xff,0xde,0x02,0xff,0xd8,0x04,0xff,0xc6,0x10,0x00,0x00,
   0x4e,0x24,0x0f,0x45,0x58,0x45,0x20,0x74,0x6f,0x20,0x63,0x6f,0x6e,0x74,0x69,0x6e,
   0x75,0x65,0x71,0x73,0x24,0x0d,0x43,0x4c,0x45,0x41,0x52,0x20,0x74,0x6f,0x20,0x71,
   0x75,0x69,0x74,0x71,0x73,0x0d,0xff,0xfc,0x91,0x7f,0x00,0xff,0xfc,0x22,0x00,0x0d,
   0x2b,0x7e,0x00,0x03,0x7b,0x4e,0x62,0x24,0x04,0x44,0x41,0x59,0x24,0x1f,0x00,0xb9,
   0x22,0x00,0x10,0xc0,0x81,0x0f,0xff,0xc7,0x24,0x04,0x44,0x41,0x59,0x24,0x1c,0x00,
   0x81,0x24,0x04,0x44,0x41,0x59,0x24,0x1f,0x00,0x6b,0x24,0x04,0x44,0x41,0x59,0x24,
   0x1c,0x00,0x02,0xff,0xc7,0x49,0x7e,0x00,0x85,0x53,0xff,0xff,0x24,0x04,0x44,0x41,
   0x59,0x24,0x1f,0x00,0x24,0x04,0x44,0x41,0x59,0x24,0x1c,0x00,0x22,0x00,0x10,0xc0,
   0x81,0x22,0x00,0x03,0x6a,0x0f,0xff,0xe3,0x8c,0x86,0x22,0x00,0x02,0xbc,0x81,0x0f,
   0xff,0xdf,0x9a,0x86,0x22,0x00,0x02,0xbc,0x81,0x0f,0xff,0xd9,0xa1,0x86,0x22,0x00,
   0x04,0xbc,0x81,0x22,0x00,0x01,0x22,0x00,0x02,0x4c,0x0f,0xff,0xe3,0x6b,0x22,0x00,
   0x04,0x22,0x00,0x02,0x4c,0x0f,0xff,0xdf,0x6b,0x22,0x00,0x08,0x22,0x00,0x02,0x4c,
   0x0f,0xff,0xd9,0x6b,0x24,0x01,0x44,0x1e,0x00,0x02,0xff,0xe3,0xb5,0x02,0xff,0xdf,
   0xb5,0x22,0x00,0x64,0x86,0x3e,0x3c,0x02,0xff,0xd9,0xb5,0x22,0x27,0x10,0x86,0x3e,
   0x3c,0x80,0x22,0x00,0x01,0x6a,0x53,0x00,0x00,0x51,0x00,0x24,0x24,0x01,0x44,0x1e,
   0x00,0xa1,0x86,0x80,0x24,0x01,0x44,0x1e,0x00,0x24,0x01,0x44,0x1b,0x00,0x22,0x27,
   0x10,0x86,0x3e,0x9a,0x22,0x00,0x64,0x2f,0x86,0x3c,0x8c,0x86,0x3c,0x80,0x4e,0x24,
   0x0c,0x45,0x4e,0x54,0x45,0x52,0x20,0x57,0x41,0x54,0x45,0x52,0x53,0x71,0x73,0x24,
   0x06,0x57,0x41,0x54,0x45,0x52,0x24,0x1f,0x00,0x6b,0x24,0x06,0x57,0x41,0x54,0x45,
   0x52,0x24,0x1f,0x00,0x24,0x06,0x57,0x41,0x54,0x45,0x52,0x24,0x1c,0x00,0xc7,0x81,
   0x4e,0x0d,0xff,0xfc,0x24,0x22,0x53,0x41,0x4c,0x4d,0x4f,0x4e,0x2c,0x53,0x45,0x41,
   0x2d,0x54,0x52,0x4f,0x55,0x54,0x2c,0x42,0x52,0x4f,0x57,0x4e,0x2d,0x54,0x52,0x4f,
   0x55,0x54,0x2c,0x4f,0x54,0x48,0x45,0x52,0x98,0x7f,0x00,0xff,0xfc,0x22,0x00,0x01,
   0x2c,0x7e,0x00,0x17,0x24,0x05,0x46,0x49,0x53,0x48,0x24,0x1f,0x00,0x24,0x06,0x53,
   0x41,0x4c,0x4d,0x4f,0x4e,0x81,0x51,0x00,0x85,0x00,0xff,0xfc,0x22,0x00,0x02,0x2c,
   0x7e,0x00,0x1a,0x24,0x05,0x46,0x49,0x53,0x48,0x24,0x1f,0x00,0x24,0x09,0x53,0x45,
   0x41,0x2d,0x54,0x52,0x4f,0x55,0x54,0x81,0x51,0x00,0x63,0x00,0xff,0xfc,0x22,0x00,
   0x03,0x2c,0x7e,0x00,0x1c,0x24,0x05,0x46,0x49,0x53,0x48,0x24,0x1f,0x00,0x24,0x0b,
   0x42,0x52,0x4f,0x57,0x4e,0x2d,0x54,0x52,0x4f,0x55,0x54,0x81,0x51,0x00,0x3f,0x00,
   0xff,0xfc,0x22,0x00,0x04,0x2c,0x7e,0x00,0x32,0x4e,0x24,0x0a,0x45,0x4e,0x54,0x45,
   0x52,0x20,0x46,0x49,0x53,0x48,0x71,0x73,0x24,0x05,0x46,0x49,0x53,0x48,0x24,0x1f,
   0x00,0x6b,0x24,0x05,0x46,0x49,0x53,0x48,0x24,0x1f,0x00,0x24,0x05,0x46,0x49,0x53,
   0x48,0x24,0x1c,0x00,0xc7,0x81,0x51,0x00,0x05,0x51,0x03,0xc2,0x4e,0x24,0x1c,0x45,
   0x4e,0x54,0x45,0x52,0x20,0x4e,0x55,0x4d,0x42,0x45,0x52,0x20,0x4f,0x46,0x20,0x46,
   0x49,0x53,0x48,0x20,0x43,0x41,0x55,0x47,0x48,0x54,0x20,0x71,0x0f,0xff,0xe7,0x24,
   0x01,0x31,0x81,0x22,0x00,0x03,0x6a,0x0f,0xff,0xe7,0x6b,0x02,0xff,0xe7,0x24,0x00,
   0x4a,0x7e,0x00,0x09,0x0f,0xff,0xe7,0x24,0x01,0x30,0x81,0x53,0xff,0xc0,0x24,0x03,
   0x4e,0x4f,0x25,0x1d,0x00,0x02,0xff,0xe7,0xb5,0x94,0x7f,0x53,0x00,0x00,0x4e,0x22,
   0x00,0x01,0x6a,0x0d,0xff,0xfc,0x24,0x08,0x46,0x4c,0x59,0x2c,0x42,0x41,0x49,0x54,
   0x98,0x7f,0x00,0xff,0xfc,0x22,0x00,0x01,0x2c,0x7e,0x00,0x60,0x4e,0x24,0x09,0x45,
   0x4e,0x54,0x45,0x52,0x20,0x46,0x4c,0x59,0x71,0x73,0x24,0x04,0x46,0x4c,0x59,0x24,
   0x1c,0x00,0x24,0x00,0x4a,0x7e,0x00,0x13,0x24,0x04,0x46,0x4c,0x59,0x24,0x1f,0x00,
   0x24,0x06,0x4e,0x4f,0x20,0x46,0x4c,0x59,0x81,0x24,0x04,0x46,0x4c,0x59,0x24,0x1f,
   0x00,0x6b,0x24,0x04,0x46,0x4c,0x59,0x24,0x1f,0x00,0x24,0x04,0x46,0x4c,0x59,0x24,
   0x1c,0x00,0xc7,0x81,0x24,0x05,0x42,0x41,0x49,0x54,0x24,0x1f,0x00,0x24,0x07,0x4e,
   0x4f,0x20,0x42,0x41,0x49,0x54,0x81,0x51,0x00,0x72,0x00,0xff,0xfc,0x22,0x00,0x02,
   0x2c,0x7e,0x00,0x65,0x4e,0x24,0x0a,0x45,0x4e,0x54,0x45,0x52,0x20,0x42,0x41,0x49,
   0x54,0x71,0x73,0x24,0x05,0x42,0x41,0x49,0x54,0x24,0x1c,0x00,0x24,0x00,0x4a,0x7e,
   0x00,0x15,0x24,0x05,0x42,0x41,0x49,0x54,0x24,0x1f,0x00,0x24,0x07,0x4e,0x4f,0x20,
   0x42,0x41,0x49,0x54,0x81,0x24,0x05,0x42,0x41,0x49,0x54,0x24,0x1f,0x00,0x6b,0x24,
   0x05,0x42,0x41,0x49,0x54,0x24,0x1f,0x00,0x24,0x05,0x42,0x41,0x49,0x54,0x24,0x1c,
   0x00,0xc7,0x81,0x24,0x04,0x46,0x4c,0x59,0x24,0x1f,0x00,0x24,0x06,0x4e,0x4f,0x20,
   0x46,0x4c,0x59,0x81,0x51,0x00,0x05,0x51,0x02,0x84,0x4e,0x24,0x0c,0x45,0x4e,0x54,
   0x45,0x52,0x20,0x57,0x45,0x49,0x47,0x48,0x54,0x71,0x73,0x22,0x00,0x03,0x6a,0x22,
   0x00,0x01,0x22,0x00,0x02,0x4c,0x53,0xff,0xe3,0x0f,0xff,0xf5,0x6e,0x02,0xff,0xf5,
   0x24,0x00,0x4a,0x7e,0x00,0x09,0x0f,0xff,0xf5,0x24,0x01,0x30,0x81,0x24,0x02,0x57,
   0x54,0x1e,0x00,0x02,0xff,0xf5,0xb5,0x80,0x53,0x00,0x00,0x4e,0x22,0x00,0x01,0x6a,
   0x0d,0xff,0xfc,0x24,0x20,0x43,0x4c,0x4f,0x55,0x44,0x59,0x2c,0x42,0x52,0x49,0x47,
   0x48,0x54,0x2c,0x52,0x41,0x49,0x4e,0x2c,0x54,0x48,0x55,0x4e,0x44,0x45,0x52,0x2c,
   0x4f,0x54,0x48,0x45,0x52,0x98,0x7f,0x00,0xff,0xfc,0x22,0x00,0x01,0x2c,0x7e,0x00,
   0x17,0x24,0x05,0x43,0x4f,0x4e,0x44,0x24,0x1f,0x00,0x24,0x06,0x43,0x4c,0x4f,0x55,
   0x44,0x59,0x81,0x51,0x00,0x9e,0x00,0xff,0xfc,0x22,0x00,0x02,0x2c,0x7e,0x00,0x17,
   0x24,0x05,0x43,0x4f,0x4e,0x44,0x24,0x1f,0x00,0x24,0x06,0x42,0x52,0x49,0x47,0x48,
   0x54,0x81,0x51,0x00,0x7f,0x00,0xff,0xfc,0x22,0x00,0x03,0x2c,0x7e,0x00,0x15,0x24,
   0x05,0x43,0x4f,0x4e,0x44,0x24,0x1f,0x00,0x24,0x04,0x52,0x41,0x49,0x4e,0x81,0x51,
   0x00,0x62,0x00,0xff,0xfc,0x22,0x00,0x04,0x2c,0x7e,0x00,0x18,0x24,0x05,0x43,0x4f,
   0x4e,0x44,0x24,0x1f,0x00,0x24,0x07,0x54,0x48,0x55,0x4e,0x44,0x45,0x52,0x81,0x51,
   0x00,0x42,0x00,0xff,0xfc,0x22,0x00,0x05,0x2c,0x7e,0x00,0x35,0x4e,0x24,0x0d,0x45,
   0x4e,0x54,0x45,0x52,0x20,0x57,0x45,0x41,0x54,0x48,0x45,0x52,0x71,0x73,0x24,0x05,
   0x43,0x4f,0x4e,0x44,0x24,0x1f,0x00,0x6b,0x24,0x05,0x43,0x4f,0x4e,0x44,0x24,0x1f,
   0x00,0x24,0x05,0x43,0x4f,0x4e,0x44,0x24,0x1c,0x00,0xc7,0x81,0x51,0x00,0x05,0x51,
   0x01,0x5c,0x4e,0x0d,0xff,0xfc,0x24,0x1d,0x4e,0x4f,0x4e,0x45,0x2c,0x48,0x49,0x2d,
   0x54,0x49,0x44,0x45,0x2c,0x4d,0x49,0x44,0x2d,0x54,0x49,0x44,0x45,0x2c,0x4c,0x4f,
   0x2d,0x54,0x49,0x44,0x45,0x98,0x7f,0x00,0xff,0xfc,0x22,0x00,0x01,0x2c,0x7e,0x00,
   0x18,0x24,0x05,0x54,0x49,0x44,0x45,0x24,0x1f,0x00,0x24,0x07,0x4e,0x4f,0x20,0x54,
   0x49,0x44,0x45,0x81,0x51,0x00,0x69,0x00,0xff,0xfc,0x22,0x00,0x02,0x2c,0x7e,0x00,
   0x1a,0x24,0x05,0x54,0x49,0x44,0x45,0x24,0x1f,0x00,0x24,0x09,0x48,0x49,0x47,0x48,
   0x2d,0x54,0x49,0x44,0x45,0x81,0x51,0x00,0x47,0x00,0xff,0xfc,0x22,0x00,0x03,0x2c,
   0x7e,0x00,0x19,0x24,0x05,0x54,0x49,0x44,0x45,0x24,0x1f,0x00,0x24,0x08,0x4d,0x49,
   0x44,0x2d,0x54,0x49,0x44,0x45,0x81,0x51,0x00,0x26,0x00,0xff,0xfc,0x22,0x00,0x04,
   0x2c,0x7e,0x00,0x19,0x24,0x05,0x54,0x49,0x44,0x45,0x24,0x1f,0x00,0x24,0x08,0x4c,
   0x4f,0x57,0x2d,0x54,0x49,0x44,0x45,0x81,0x51,0x00,0x05,0x51,0x00,0xb0,0x4e,0x0d,
   0xff,0xfc,0x24,0x10,0x41,0x4d,0x2c,0x50,0x4d,0x2c,0x4e,0x4f,0x4f,0x4e,0x2c,0x4e,
   0x49,0x47,0x48,0x54,0x98,0x7f,0x00,0xff,0xfc,0x22,0x00,0x01,0x2c,0x7e,0x00,0x13,
   0x24,0x05,0x54,0x49,0x4d,0x45,0x24,0x1f,0x00,0x24,0x02,0x41,0x4d,0x81,0x51,0x00,
   0x5b,0x00,0xff,0xfc,0x22,0x00,0x02,0x2c,0x7e,0x00,0x13,0x24,0x05,0x54,0x49,0x4d,
   0x45,0x24,0x1f,0x00,0x24,0x02,0x50,0x4d,0x81,0x51,0x00,0x40,0x00,0xff,0xfc,0x22,
   0x00,0x03,0x2c,0x7e,0x00,0x15,0x24,0x05,0x54,0x49,0x4d,0x45,0x24,0x1f,0x00,0x24,
   0x04,0x4e,0x4f,0x4f,0x4e,0x81,0x51,0x00,0x23,0x00,0xff,0xfc,0x22,0x00,0x04,0x2c,
   0x7e,0x00,0x16,0x24,0x05,0x54,0x49,0x4d,0x45,0x24,0x1f,0x00,0x24,0x05,0x4e,0x49,
   0x47,0x48,0x54,0x81,0x51,0x00,0x05,0x51,0x00,0x24,0x4e,0x24,0x0e,0x45,0x4e,0x54,
   0x45,0x52,0x20,0x43,0x4f,0x4d,0x4d,0x45,0x4e,0x54,0x53,0x71,0x73,0x24,0x08,0x43,
   0x4f,0x4d,0x4d,0x45,0x4e,0x54,0x24,0x1f,0x00,0x6e,0x5b,0x7b,0x4e,0x0d,0xff,0xfc,
   0x24,0x0a,0x53,0x41,0x56,0x45,0x2c,0x41,0x42,0x4f,0x52,0x54,0x98,0x7f,0x00,0xff,
   0xfc,0x22,0x00,0x01,0x2c,0x7e,0x00,0x06,0x5b,0x51,0x00,0x03,0x7b,0x7b,0x00,0x00,
   0x09,0x83,0x46,0x49,0x53,0x48,0x53,0x45,0x45,0x20,0x00,0x02,0x80,0x05,0x0e,0x05,
   0x0a,0x00,0x32,0x04,0xf7,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0xff,0xea,0x10,0xff,
   0xd0,0x10,0x00,0x00,0x22,0x00,0x01,0x6a,0x4e,0x0d,0xff,0xe4,0x24,0x18,0x46,0x49,
   0x4e,0x44,0x2c,0x45,0x44,0x49,0x54,0x2c,0x4e,0x4f,0x2e,0x2d,0x4f,0x46,0x2d,0x52,
   0x45,0x43,0x4f,0x52,0x44,0x53,0x98,0x7f,0x00,0xff,0xe4,0x22,0x00,0x01,0x2c,0x7e,
   0x00,0x0c,0x0d,0xff,0xe2,0x22,0x00,0x00,0x7f,0x51,0x00,0x45,0x00,0xff,0xe4,0x22,
   0x00,0x02,0x2c,0x7e,0x00,0x0c,0x0d,0xff,0xe2,0x22,0x00,0x01,0x7f,0x51,0x00,0x31,
   0x00,0xff,0xe4,0x22,0x00,0x03,0x2c,0x7e,0x00,0x26,0x4e,0x24,0x0f,0x4e,0x4f,0x2e,
   0x20,0x4f,0x46,0x20,0x52,0x45,0x43,0x4f,0x52,0x44,0x53,0x3d,0x71,0x73,0x0d,0xff,
   0xe4,0xa2,0x7f,0xa2,0x6f,0x73,0x91,0x83,0x51,0xff,0x8b,0x51,0x00,0x03,0x7b,0x61,
   0x24,0x06,0x46,0x49,0x4e,0x44,0x3a,0x20,0x71,0x73,0x0d,0xff,0xe6,0x95,0x7f,0x0f,
   0xff,0xeb,0x6e,0x00,0xff,0xe6,0x22,0x00,0x01,0x2c,0x7e,0x00,0x03,0x7b,0x0d,0xff,
   0xfc,0x22,0x00,0x00,0x7f,0x0d,0xff,0xfc,0x02,0xff,0xeb,0x8f,0x7f,0x00,0xff,0xfc,
   0x22,0x00,0x00,0x2c,0x7e,0x00,0x1b,0x4e,0x24,0x0f,0x2a,0x2a,0x45,0x4e,0x44,0x20,
   0x4f,0x46,0x20,0x46,0x49,0x4c,0x45,0x2a,0x2a,0x71,0x73,0x91,0x83,0x51,0xff,0x36,
   0x00,0xff,0xe2,0x22,0x00,0x01,0x2c,0x7e,0x00,0x05,0x51,0x00,0x62,0x4e,0xa3,0x7e,
   0x00,0x1a,0x24,0x0f,0x2a,0x2a,0x45,0x4e,0x44,0x20,0x4f,0x46,0x20,0x46,0x49,0x4c,
   0x45,0x2a,0x2a,0x71,0x73,0x91,0x83,0x51,0xff,0x0c,0x0d,0xff,0xe8,0x22,0x00,0x01,
   0x32,0x24,0x00,0x8d,0x7f,0x00,0xff,0xe8,0x22,0x00,0x0d,0x2b,0x7e,0x00,0x1c,0x0d,
   0xff,0xe8,0x22,0x00,0x00,0x24,0x00,0x8d,0x7f,0x00,0xff,0xe8,0x22,0x00,0x01,0x2c,
   0x7e,0x00,0x05,0x51,0x00,0x05,0x51,0xff,0xde,0x00,0xff,0xe8,0x22,0x00,0x01,0x2c,
   0x7e,0x00,0x08,0x51,0xfe,0xd0,0x51,0x00,0x06,0x63,0x51,0xff,0x6a,0x4e,0x22,0x00,
   0x01,0x22,0x00,0x01,0x4c,0x24,0x07,0x45,0x44,0x3a,0x44,0x41,0x54,0x45,0x71,0x73,
   0x0f,0xff,0xd1,0x24,0x04,0x44,0x41,0x59,0x24,0x1c,0x00,0x81,0x22,0x00,0x01,0x22,
   0x00,0x02,0x4c,0x24,0x04,0x44,0x41,0x59,0x24,0x1f,0x00,0x6b,0x24,0x04,0x44,0x41,
   0x59,0x24,0x1c,0x00,0x24,0x00,0x4a,0x7e,0x00,0x05,0x51,0xfe,0x89,0x24,0x04,0x44,
   0x41,0x59,0x24,0x1c,0x00,0x02,0xff,0xd1,0x49,0x7e,0x00,0x60,0x4e,0x24,0x0f,0x45,
   0x44,0x3a,0x28,0x79,0x79,0x79,0x79,0x20,0x6d,0x6d,0x20,0x64,0x64,0x29,0x71,0x73,
   0x24,0x04,0x44,0x41,0x59,0x24,0x1f,0x00,0x24,0x04,0x44,0x41,0x59,0x24,0x1c,0x00,
   0x22,0x00,0x10,0xc0,0x81,0x53,0xff,0xd6,0x22,0x00,0x03,0x6a,0x0f,0xff,0xd1,0x24,
   0x01,0x44,0x1b,0x00,0x22,0x00,0x08,0xbc,0x81,0x0f,0xff,0xd1,0x6b,0x02,0xff,0xd1,
   0x24,0x00,0x4a,0x7e,0x00,0x05,0x51,0xfe,0x2d,0x24,0x01,0x44,0x1e,0x00,0x02,0xff,
   0xd1,0xb5,0x80,0x22,0x00,0x01,0x6a,0x53,0x00,0x00,0x4e,0x24,0x09,0x45,0x44,0x3a,
   0x57,0x41,0x54,0x45,0x52,0x53,0x71,0x73,0x22,0x00,0x01,0x22,0x00,0x02,0x4c,0x24,
   0x06,0x57,0x41,0x54,0x45,0x52,0x24,0x1f,0x00,0x6b,0x24,0x06,0x57,0x41,0x54,0x45,
   0x52,0x24,0x1c,0x00,0x24,0x00,0x4a,0x7e,0x00,0x05,0x51,0xfd,0xe9,0x24,0x06,0x57,
   0x41,0x54,0x45,0x52,0x24,0x1f,0x00,0x24,0x06,0x57,0x41,0x54,0x45,0x52,0x24,0x1c,
   0x00,0xc7,0x81,0x4e,0x24,0x07,0x45,0x44,0x3a,0x46,0x49,0x53,0x48,0x71,0x73,0x22,
   0x00,0x01,0x22,0x00,0x02,0x4c,0x24,0x05,0x46,0x49,0x53,0x48,0x24,0x1f,0x00,0x6b,
   0x24,0x05,0x46,0x49,0x53,0x48,0x24,0x1c,0x00,0x24,0x00,0x4a,0x7e,0x00,0x05,0x51,
   0xfd,0xa4,0x24,0x05,0x46,0x49,0x53,0x48,0x24,0x1f,0x00,0x24,0x05,0x46,0x49,0x53,
   0x48,0x24,0x1c,0x00,0xc7,0x81,0x0f,0xff,0xd1,0x24,0x03,0x4e,0x4f,0x25,0x1a,0x00,
   0x86,0x22,0x00,0x06,0xbc,0x81,0x4e,0x24,0x0e,0x45,0x44,0x3a,0x4e,0x4f,0x2e,0x20,
   0x4f,0x46,0x20,0x46,0x49,0x53,0x48,0x71,0x73,0x53,0xff,0xec,0x22,0x00,0x03,0x6a,
   0x22,0x00,0x01,0x22,0x00,0x02,0x4c,0x24,0x04,0x4e,0x4f,0x3a,0x20,0x71,0x73,0x22,
   0x00,0x05,0x22,0x00,0x02,0x4c,0x0f,0xff,0xd1,0x6b,0x02,0xff,0xd1,0x24,0x00,0x4a,
   0x7e,0x00,0x05,0x51,0xfd,0x40,0x24,0x03,0x4e,0x4f,0x25,0x1d,0x00,0x02,0xff,0xd1,
   0xb5,0x87,0x7f,0x53,0x00,0x00,0x0f,0xff,0xd1,0x24,0x02,0x57,0x54,0x1b,0x00,0x22,
   0x00,0x08,0xbc,0x81,0x4e,0x24,0x09,0x45,0x44,0x3a,0x57,0x45,0x49,0x47,0x48,0x54,
   0x71,0x73,0x53,0xff,0xf1,0x22,0x00,0x01,0x22,0x00,0x02,0x4c,0x24,0x04,0x57,0x54,
   0x3a,0x20,0x71,0x73,0x22,0x00,0x05,0x22,0x00,0x02,0x4c,0x0f,0xff,0xd1,0x6b,0x02,
   0xff,0xd1,0x24,0x00,0x4a,0x7e,0x00,0x05,0x51,0xfc,0xeb,0x24,0x02,0x57,0x54,0x1e,
   0x00,0x02,0xff,0xd1,0xb5,0x80,0x22,0x00,0x01,0x6a,0x53,0x00,0x00,0x4e,0x24,0x06,
   0x45,0x44,0x3a,0x46,0x4c,0x59,0x71,0x73,0x22,0x00,0x01,0x22,0x00,0x02,0x4c,0x24,
   0x04,0x46,0x4c,0x59,0x24,0x1f,0x00,0x6b,0x24,0x04,0x46,0x4c,0x59,0x24,0x1c,0x00,
   0x24,0x00,0x4a,0x7e,0x00,0x05,0x51,0xfc,0xad,0x24,0x04,0x46,0x4c,0x59,0x24,0x1f,
   0x00,0x24,0x04,0x46,0x4c,0x59,0x24,0x1c,0x00,0xc7,0x81,0x4e,0x24,0x07,0x45,0x44,
   0x3a,0x42,0x41,0x49,0x54,0x71,0x73,0x22,0x00,0x01,0x22,0x00,0x02,0x4c,0x24,0x05,
   0x42,0x41,0x49,0x54,0x24,0x1f,0x00,0x6b,0x24,0x05,0x42,0x41,0x49,0x54,0x24,0x1c,
   0x00,0x24,0x00,0x4a,0x7e,0x00,0x05,0x51,0xfc,0x6c,0x24,0x05,0x42,0x41,0x49,0x54,
   0x24,0x1f,0x00,0x24,0x05,0x42,0x41,0x49,0x54,0x24,0x1c,0x00,0xc7,0x81,0x4e,0x24,
   0x0e,0x45,0x44,0x3a,0x54,0x49,0x4d,0x45,0x20,0x4f,0x46,0x20,0x44,0x41,0x59,0x71,
   0x73,0x22,0x00,0x01,0x22,0x00,0x02,0x4c,0x24,0x05,0x54,0x49,0x4d,0x45,0x24,0x1f,
   0x00,0x6b,0x24,0x05,0x54,0x49,0x4d,0x45,0x24,0x1c,0x00,0x24,0x00,0x4a,0x7e,0x00,
   0x05,0x51,0xfc,0x22,0x24,0x05,0x54,0x49,0x4d,0x45,0x24,0x1f,0x00,0x24,0x05,0x54,
   0x49,0x4d,0x45,0x24,0x1c,0x00,0xc7,0x81,0x4e,0x24,0x07,0x45,0x44,0x3a,0x54,0x49,
   0x44,0x45,0x71,0x73,0x22,0x00,0x01,0x22,0x00,0x02,0x4c,0x24,0x05,0x54,0x49,0x44,
   0x45,0x24,0x1f,0x00,0x6b,0x24,0x05,0x54,0x49,0x44,0x45,0x24,0x1c,0x00,0x24,0x00,
   0x4a,0x7e,0x00,0x05,0x51,0xfb,0xdf,0x24,0x05,0x54,0x49,0x44,0x45,0x24,0x1f,0x00,
   0x24,0x05,0x54,0x49,0x44,0x45,0x24,0x1c,0x00,0xc7,0x81,0x4e,0x24,0x0a,0x45,0x44,
   0x3a,0x57,0x45,0x41,0x54,0x48,0x45,0x52,0x71,0x73,0x22,0x00,0x01,0x22,0x00,0x02,
   0x4c,0x24,0x05,0x43,0x4f,0x4e,0x44,0x24,0x1f,0x00,0x6b,0x24,0x05,0x43,0x4f,0x4e,
   0x44,0x24,0x1c,0x00,0x24,0x00,0x4a,0x7e,0x00,0x05,0x51,0xfb,0x99,0x24,0x05,0x43,
   0x4f,0x4e,0x44,0x24,0x1f,0x00,0x24,0x05,0x43,0x4f,0x4e,0x44,0x24,0x1c,0x00,0xc7,
   0x81,0x4e,0x4e,0x24,0x0a,0x45,0x44,0x3a,0x43,0x4f,0x4d,0x4d,0x45,0x4e,0x54,0x71,
   0x73,0x22,0x00,0x01,0x22,0x00,0x02,0x4c,0x24,0x08,0x43,0x4f,0x4d,0x4d,0x45,0x4e,
   0x54,0x24,0x1f,0x00,0x6b,0x4e,0x0d,0xff,0xce,0x24,0x17,0x53,0x41,0x56,0x45,0x2c,
   0x49,0x47,0x4e,0x4f,0x52,0x45,0x2c,0x44,0x45,0x4c,0x45,0x54,0x45,0x2c,0x51,0x55,
   0x49,0x54,0x98,0x7f,0x00,0xff,0xce,0x22,0x00,0x01,0x2c,0x7e,0x00,0x09,0x68,0x51,
   0xfb,0x34,0x51,0x00,0x27,0x00,0xff,0xce,0x22,0x00,0x02,0x2c,0x7e,0x00,0x09,0x63,
   0x51,0xfb,0xc4,0x51,0x00,0x16,0x00,0xff,0xce,0x22,0x00,0x03,0x2c,0x7e,0x00,0x09,
   0x60,0x51,0xfb,0x12,0x51,0x00,0x05,0x51,0xfb,0x0c,0x7b,0x00,0x00,0x09,0x83,0x46,
   0x49,0x53,0x48,0x43,0x52,0x20,0x20,0x00,0x02,0x80,0x00,0xb7,0x00,0xb3,0x00,0x06,
   0x00,0xa1,0x00,0x00,0x00,0x00,0x05,0x03,0x44,0x52,0x24,0x02,0x00,0x00,0x00,0x00,
   0x0d,0xff,0xfa,0x20,0x00,0x7d,0x06,0x50,0x41,0x43,0x4b,0x49,0x4e,0x87,0x7f,0x00,
   0xff,0xfa,0x22,0x00,0x00,0x2c,0x7e,0x00,0x03,0x7b,0x09,0xff,0xfc,0x24,0x04,0x46,
   0x49,0x53,0x48,0x4b,0x5e,0x00,0x02,0x04,0x44,0x41,0x59,0x24,0x02,0x06,0x57,0x41,
   0x54,0x45,0x52,0x24,0x02,0x05,0x46,0x49,0x53,0x48,0x24,0x00,0x03,0x4e,0x4f,0x25,
   0x01,0x02,0x57,0x54,0x02,0x04,0x46,0x4c,0x59,0x24,0x02,0x05,0x42,0x41,0x49,0x54,
   0x24,0x02,0x05,0x54,0x49,0x4d,0x45,0x24,0x02,0x05,0x54,0x49,0x44,0x45,0x24,0x02,
   0x05,0x43,0x4f,0x4e,0x44,0x24,0x02,0x08,0x43,0x4f,0x4d,0x4d,0x45,0x4e,0x54,0x24,
   0x01,0x01,0x44,0x88,0x4e,0x24,0x0e,0x46,0x49,0x53,0x48,0x20,0x46,0x49,0x4c,0x45,
   0x20,0x4d,0x41,0x44,0x45,0x71,0x22,0x00,0x0f,0xb8,0x71,0x24,0x04,0x4f,0x4e,0x20,
   0x20,0x71,0x09,0xff,0xfc,0x71,0x24,0x06,0x20,0x44,0x52,0x49,0x56,0x45,0x71,0x73,
   0x7b,0x00,0x00,0x09,0x83,0x46,0x49,0x53,0x48,0x4f,0x50,0x20,0x20,0x00,0x02,0x80,
   0x00,0x6a,0x00,0x66,0x00,0x04,0x00,0x55,0x00,0x00,0x00,0x00,0x04,0x02,0x46,0x24,
   0x02,0x00,0x00,0x00,0x00,0x09,0xff,0xfc,0x5a,0x65,0x00,0x02,0x04,0x44,0x41,0x59,
   0x24,0x02,0x06,0x57,0x41,0x54,0x45,0x52,0x24,0x02,0x05,0x46,0x49,0x53,0x48,0x24,
   0x00,0x03,0x4e,0x4f,0x25,0x01,0x02,0x57,0x54,0x02,0x04,0x46,0x4c,0x59,0x24,0x02,
   0x05,0x42,0x41,0x49,0x54,0x24,0x02,0x05,0x54,0x49,0x4d,0x45,0x24,0x02,0x05,0x54,
   0x49,0x44,0x45,0x24,0x02,0x05,0x43,0x4f,0x4e,0x44,0x24,0x02,0x08,0x43,0x4f,0x4d,
   0x4d,0x45,0x4e,0x54,0x24,0x01,0x01,0x44,0x88,0x7b,0x00,0x00,0x09,0x83,0x46,0x49,
   0x53,0x48,0x52,0x45,0x50,0x20,0x00,0x02,0x80,0x0a,0x9a,0x0a,0x96,0x02,0x9b,0x0a,
   0x45,0x00,0x00,0x24,0x02,0x52,0x24,0x05,0xfe,0x6d,0x02,0x43,0x25,0x00,0xfe,0x6a,
   0x03,0x42,0x49,0x47,0x01,0xfe,0x62,0x05,0x42,0x44,0x41,0x59,0x24,0x02,0xfe,0x51,
   0x04,0x43,0x4f,0x4d,0x24,0x02,0xfe,0x3f,0x00,0x00,0x00,0x18,0xfe,0x6c,0x20,0xfe,
   0x50,0x10,0xfe,0x3e,0x10,0xfe,0x1e,0x02,0xfe,0x1a,0x02,0xfe,0x14,0x04,0xfd,0x89,
   0x10,0xfd,0x65,0x20,0x00,0x08,0xfe,0x6d,0x00,0x0b,0xfd,0x8a,0x00,0x08,0x4e,0x0d,
   0xfe,0x32,0x24,0x10,0x46,0x49,0x53,0x48,0x49,0x4e,0x47,0x20,0x52,0x45,0x53,0x55,
   0x4c,0x54,0x53,0x3a,0x98,0x7f,0x00,0xfe,0x32,0x22,0x00,0x01,0x2b,0x7e,0x00,0x03,
   0x7b,0x22,0x00,0x03,0x6a,0x53,0xff,0xff,0x4e,0x24,0x08,0x46,0x52,0x4f,0x4d,0x20,
   0x64,0x64,0x20,0x71,0x73,0x22,0x00,0x06,0x22,0x00,0x02,0x4c,0x0f,0xfe,0x1f,0x6e,
   0x02,0xfe,0x1f,0x24,0x00,0x4a,0x7e,0x00,0x22,0x0e,0xfe,0x2a,0x22,0x00,0x00,0x86,
   0x80,0x0f,0xfd,0x66,0x24,0x0f,0x46,0x52,0x4f,0x4d,0x3a,0x20,0x42,0x45,0x47,0x49,
   0x4e,0x4e,0x49,0x4e,0x47,0x81,0x51,0x00,0x72,0x22,0x00,0x09,0x22,0x00,0x01,0x4c,
   0x24,0x02,0x6d,0x6d,0x71,0x73,0x22,0x00,0x09,0x22,0x00,0x02,0x4c,0x0f,0xfe,0x1b,
   0x6e,0x22,0x00,0x0c,0x22,0x00,0x01,0x4c,0x24,0x04,0x79,0x79,0x79,0x79,0x71,0x73,
   0x22,0x00,0x0c,0x22,0x00,0x02,0x4c,0x0f,0xfe,0x15,0x6e,0x0e,0xfe,0x2a,0x02,0xfe,
   0x1f,0xb5,0x02,0xfe,0x1b,0xb5,0x22,0x00,0x64,0x86,0x3e,0x3c,0x02,0xfe,0x15,0xb5,
   0x22,0x27,0x10,0x86,0x3e,0x3c,0x80,0x0f,0xfd,0x66,0x24,0x05,0x46,0x52,0x4f,0x4d,
   0x3a,0x02,0xfe,0x15,0x4b,0x24,0x01,0x2f,0x4b,0x02,0xfe,0x1b,0x4b,0x24,0x01,0x2f,
   0x4b,0x02,0xfe,0x1f,0x4b,0x81,0x53,0x00,0x00,0x53,0x00,0x00,0x53,0xff,0xfc,0x4e,
   0x24,0x08,0x20,0x54,0x4f,0x20,0x20,0x64,0x64,0x20,0x71,0x73,0x22,0x00,0x06,0x22,
   0x00,0x02,0x4c,0x0f,0xfe,0x1f,0x6e,0x02,0xfe,0x1f,0x24,0x00,0x4a,0x02,0xfe,0x1f,
   0x24,0x03,0x41,0x4c,0x4c,0x4a,0x35,0x7e,0x00,0x29,0x0e,0xfe,0x22,0x23,0x05,0x99,
   0x99,0x99,0x99,0x07,0x80,0x0f,0xfd,0x66,0x02,0xfd,0x66,0x24,0x0f,0x20,0x54,0x4f,
   0x3a,0x45,0x4e,0x44,0x20,0x4f,0x46,0x20,0x46,0x49,0x4c,0x45,0x4b,0x81,0x51,0x00,
   0x76,0x22,0x00,0x09,0x22,0x00,0x01,0x4c,0x24,0x02,0x6d,0x6d,0x71,0x73,0x22,0x00,
   0x09,0x22,0x00,0x02,0x4c,0x0f,0xfe,0x1b,0x6e,0x22,0x00,0x0c,0x22,0x00,0x01,0x4c,
   0x24,0x04,0x79,0x79,0x79,0x79,0x71,0x73,0x22,0x00,0x0c,0x22,0x00,0x02,0x4c,0x0f,
   0xfe,0x15,0x6e,0x0e,0xfe,0x22,0x02,0xfe,0x1f,0xb5,0x02,0xfe,0x1b,0xb5,0x22,0x00,
   0x64,0x86,0x3e,0x3c,0x02,0xfe,0x15,0xb5,0x22,0x27,0x10,0x86,0x3e,0x3c,0x80,0x0f,
   0xfd,0x66,0x02,0xfd,0x66,0x24,0x05,0x20,0x20,0x54,0x4f,0x3a,0x4b,0x02,0xfe,0x15,
   0x4b,0x24,0x01,0x2f,0x4b,0x02,0xfe,0x1b,0x4b,0x24,0x01,0x2f,0x4b,0x02,0xfe,0x1f,
   0x4b,0x81,0x53,0x00,0x00,0x53,0x00,0x00,0x22,0x00,0x01,0x6a,0x0d,0xfd,0x87,0x22,
   0x00,0x01,0x7f,0x4e,0x24,0x0c,0x45,0x4e,0x54,0x45,0x52,0x20,0x57,0x41,0x54,0x45,
   0x52,0x53,0x71,0x73,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x6e,0x00,0xfd,0x87,0x05,0xfd,
   0x8a,0x24,0x00,0x4a,0x00,0xfd,0x87,0x05,0xfd,0x8a,0x24,0x03,0x41,0x4c,0x4c,0x4a,
   0x35,0x7e,0x00,0x0b,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x24,0x00,0x81,0x0d,0xfd,0x87,
   0x00,0xfd,0x87,0x22,0x00,0x01,0x2d,0x7f,0x0d,0xfe,0x32,0x24,0x26,0x41,0x4c,0x4c,
   0x2c,0x53,0x41,0x4c,0x4d,0x4f,0x4e,0x2c,0x53,0x45,0x41,0x2d,0x54,0x52,0x4f,0x55,
   0x54,0x2c,0x42,0x52,0x4f,0x57,0x4e,0x2d,0x54,0x52,0x4f,0x55,0x54,0x2c,0x4f,0x54,
   0x48,0x45,0x52,0x98,0x7f,0x00,0xfe,0x32,0x22,0x00,0x01,0x2c,0x7e,0x00,0x0e,0x00,
   0xfd,0x87,0x12,0xfd,0x8a,0x24,0x00,0x81,0x51,0x00,0x90,0x00,0xfe,0x32,0x22,0x00,
   0x02,0x2c,0x7e,0x00,0x14,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x24,0x06,0x53,0x41,0x4c,
   0x4d,0x4f,0x4e,0x81,0x51,0x00,0x74,0x00,0xfe,0x32,0x22,0x00,0x03,0x2c,0x7e,0x00,
   0x17,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x24,0x09,0x53,0x45,0x41,0x2d,0x54,0x52,0x4f,
   0x55,0x54,0x81,0x51,0x00,0x55,0x00,0xfe,0x32,0x22,0x00,0x04,0x2c,0x7e,0x00,0x19,
   0x00,0xfd,0x87,0x12,0xfd,0x8a,0x24,0x0b,0x42,0x52,0x4f,0x57,0x4e,0x2d,0x54,0x52,
   0x4f,0x55,0x54,0x81,0x51,0x00,0x34,0x00,0xfe,0x32,0x22,0x00,0x05,0x2c,0x7e,0x00,
   0x29,0x4e,0x24,0x0a,0x45,0x4e,0x54,0x45,0x52,0x20,0x46,0x49,0x53,0x48,0x71,0x73,
   0x00,0xfd,0x87,0x12,0xfd,0x8a,0x6e,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x00,0xfd,0x87,
   0x05,0xfd,0x8a,0xc7,0x81,0x51,0x00,0x03,0x7b,0x0d,0xfd,0x87,0x00,0xfd,0x87,0x22,
   0x00,0x01,0x2d,0x7f,0x0d,0xfe,0x32,0x24,0x0c,0x41,0x4c,0x4c,0x2c,0x46,0x4c,0x59,
   0x2c,0x42,0x41,0x49,0x54,0x98,0x7f,0x00,0xfe,0x32,0x22,0x00,0x01,0x2c,0x7e,0x00,
   0x0e,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x24,0x00,0x81,0x51,0x00,0x48,0x00,0xfe,0x32,
   0x22,0x00,0x02,0x2c,0x7e,0x00,0x1a,0x4e,0x24,0x09,0x45,0x4e,0x54,0x45,0x52,0x20,
   0x46,0x4c,0x59,0x71,0x73,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x6e,0x51,0x00,0x26,0x00,
   0xfe,0x32,0x22,0x00,0x03,0x2c,0x7e,0x00,0x1b,0x4e,0x24,0x0a,0x45,0x4e,0x54,0x45,
   0x52,0x20,0x42,0x41,0x49,0x54,0x71,0x73,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x6e,0x51,
   0x00,0x03,0x7b,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x00,0xfd,0x87,0x05,0xfd,0x8a,0xc7,
   0x81,0x0d,0xfd,0x87,0x00,0xfd,0x87,0x22,0x00,0x01,0x2d,0x7f,0x0d,0xfe,0x32,0x24,
   0x14,0x41,0x4c,0x4c,0x2c,0x41,0x4d,0x2c,0x50,0x4d,0x2c,0x4e,0x4f,0x4f,0x4e,0x2c,
   0x4e,0x49,0x47,0x48,0x54,0x98,0x7f,0x00,0xfe,0x32,0x22,0x00,0x01,0x2c,0x7e,0x00,
   0x0e,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x24,0x00,0x81,0x51,0x00,0x68,0x00,0xfe,0x32,
   0x22,0x00,0x02,0x2c,0x7e,0x00,0x10,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x24,0x02,0x41,
   0x4d,0x81,0x51,0x00,0x50,0x00,0xfe,0x32,0x22,0x00,0x03,0x2c,0x7e,0x00,0x10,0x00,
   0xfd,0x87,0x12,0xfd,0x8a,0x24,0x02,0x50,0x4d,0x81,0x51,0x00,0x38,0x00,0xfe,0x32,
   0x22,0x00,0x04,0x2c,0x7e,0x00,0x12,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x24,0x04,0x4e,
   0x4f,0x4f,0x4e,0x81,0x51,0x00,0x1e,0x00,0xfe,0x32,0x22,0x00,0x05,0x2c,0x7e,0x00,
   0x13,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x24,0x05,0x4e,0x49,0x47,0x48,0x54,0x81,0x51,
   0x00,0x03,0x7b,0x0d,0xfd,0x87,0x00,0xfd,0x87,0x22,0x00,0x01,0x2d,0x7f,0x0d,0xfe,
   0x32,0x24,0x1c,0x41,0x4c,0x4c,0x2c,0x48,0x49,0x2d,0x54,0x49,0x44,0x45,0x2c,0x4d,
   0x49,0x44,0x2d,0x54,0x49,0x44,0x45,0x2c,0x4c,0x4f,0x2d,0x54,0x49,0x44,0x45,0x98,
   0x7f,0x00,0xfe,0x32,0x22,0x00,0x01,0x2c,0x7e,0x00,0x0e,0x00,0xfd,0x87,0x12,0xfd,
   0x8a,0x24,0x00,0x81,0x51,0x00,0x5e,0x00,0xfe,0x32,0x22,0x00,0x02,0x2c,0x7e,0x00,
   0x17,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x24,0x09,0x48,0x49,0x47,0x48,0x2d,0x54,0x49,
   0x44,0x45,0x81,0x51,0x00,0x3f,0x00,0xfe,0x32,0x22,0x00,0x03,0x2c,0x7e,0x00,0x16,
   0x00,0xfd,0x87,0x12,0xfd,0x8a,0x24,0x08,0x4d,0x49,0x44,0x2d,0x54,0x49,0x44,0x45,
   0x81,0x51,0x00,0x21,0x00,0xfe,0x32,0x22,0x00,0x04,0x2c,0x7e,0x00,0x16,0x00,0xfd,
   0x87,0x12,0xfd,0x8a,0x24,0x08,0x4c,0x4f,0x57,0x2d,0x54,0x49,0x44,0x45,0x81,0x51,
   0x00,0x03,0x7b,0x0d,0xfd,0x87,0x00,0xfd,0x87,0x22,0x00,0x01,0x2d,0x7f,0x0d,0xfe,
   0x32,0x24,0x24,0x41,0x4c,0x4c,0x2c,0x43,0x4c,0x4f,0x55,0x44,0x59,0x2c,0x42,0x52,
   0x49,0x47,0x48,0x54,0x2c,0x52,0x41,0x49,0x4e,0x2c,0x54,0x48,0x55,0x4e,0x44,0x45,
   0x52,0x2c,0x4f,0x54,0x48,0x45,0x52,0x98,0x7f,0x00,0xfe,0x32,0x22,0x00,0x01,0x2c,
   0x7e,0x00,0x0e,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x24,0x00,0x81,0x51,0x00,0xa6,0x00,
   0xfe,0x32,0x22,0x00,0x02,0x2c,0x7e,0x00,0x14,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x24,
   0x06,0x43,0x4c,0x4f,0x55,0x44,0x59,0x81,0x51,0x00,0x8a,0x00,0xfe,0x32,0x22,0x00,
   0x03,0x2c,0x7e,0x00,0x14,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x24,0x06,0x42,0x52,0x49,
   0x47,0x48,0x54,0x81,0x51,0x00,0x6e,0x00,0xfe,0x32,0x22,0x00,0x04,0x2c,0x7e,0x00,
   0x12,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x24,0x04,0x52,0x41,0x49,0x4e,0x81,0x51,0x00,
   0x54,0x00,0xfe,0x32,0x22,0x00,0x05,0x2c,0x7e,0x00,0x15,0x00,0xfd,0x87,0x12,0xfd,
   0x8a,0x24,0x07,0x54,0x48,0x55,0x4e,0x44,0x45,0x52,0x81,0x51,0x00,0x37,0x00,0xfe,
   0x32,0x22,0x00,0x06,0x2c,0x7e,0x00,0x2c,0x4e,0x24,0x0d,0x45,0x4e,0x54,0x45,0x52,
   0x20,0x57,0x45,0x41,0x54,0x48,0x45,0x52,0x71,0x73,0x00,0xfd,0x87,0x12,0xfd,0x8a,
   0x6e,0x00,0xfd,0x87,0x12,0xfd,0x8a,0x00,0xfd,0x87,0x05,0xfd,0x8a,0xc7,0x81,0x51,
   0x00,0x03,0x7b,0x0d,0xfd,0x87,0x00,0xfd,0x87,0x22,0x00,0x01,0x2d,0x7f,0x4e,0x24,
   0x0b,0x43,0x4f,0x4d,0x4d,0x45,0x4e,0x54,0x20,0x3d,0x20,0x3f,0x71,0x73,0x00,0xfd,
   0x87,0x12,0xfd,0x8a,0x6e,0x4e,0x24,0x10,0x50,0x6c,0x65,0x61,0x73,0x65,0x20,0x77,
   0x61,0x69,0x74,0x2e,0x2e,0x2e,0x2e,0x2e,0x71,0x73,0x61,0x0d,0xfe,0x3c,0x22,0x00,
   0x00,0x7f,0x0e,0xfe,0x34,0x22,0x00,0x00,0x86,0x80,0x0e,0xfe,0x62,0x22,0x00,0x00,
   0x86,0x80,0x0f,0xfe,0x51,0x24,0x00,0x81,0xa3,0x33,0x7e,0x01,0x40,0x24,0x01,0x44,
   0x1b,0x00,0x01,0xfe,0x2a,0x39,0x24,0x01,0x44,0x1b,0x00,0x01,0xfe,0x22,0x37,0x34,
   0x7e,0x01,0x26,0x24,0x06,0x57,0x41,0x54,0x45,0x52,0x24,0x1c,0x00,0x22,0x00,0x01,
   0x05,0xfd,0x8a,0x4a,0x22,0x00,0x01,0x05,0xfd,0x8a,0x24,0x00,0x4a,0x35,0x7e,0x01,
   0x08,0x24,0x05,0x46,0x49,0x53,0x48,0x24,0x1c,0x00,0x22,0x00,0x02,0x05,0xfd,0x8a,
   0x4a,0x22,0x00,0x02,0x05,0xfd,0x8a,0x24,0x00,0x4a,0x35,0x7e,0x00,0xeb,0x24,0x04,
   0x46,0x4c,0x59,0x24,0x1c,0x00,0x22,0x00,0x03,0x05,0xfd,0x8a,0x4a,0x24,0x05,0x42,
   0x41,0x49,0x54,0x24,0x1c,0x00,0x22,0x00,0x03,0x05,0xfd,0x8a,0x4a,0x35,0x22,0x00,
   0x03,0x05,0xfd,0x8a,0x24,0x00,0x4a,0x35,0x7e,0x00,0xbe,0x24,0x05,0x54,0x49,0x4d,
   0x45,0x24,0x1c,0x00,0x22,0x00,0x04,0x05,0xfd,0x8a,0x4a,0x22,0x00,0x04,0x05,0xfd,
   0x8a,0x24,0x00,0x4a,0x35,0x7e,0x00,0xa1,0x24,0x05,0x54,0x49,0x44,0x45,0x24,0x1c,
   0x00,0x22,0x00,0x05,0x05,0xfd,0x8a,0x4a,0x22,0x00,0x05,0x05,0xfd,0x8a,0x24,0x00,
   0x4a,0x35,0x7e,0x00,0x84,0x24,0x05,0x43,0x4f,0x4e,0x44,0x24,0x1c,0x00,0x22,0x00,
   0x06,0x05,0xfd,0x8a,0x4a,0x22,0x00,0x06,0x05,0xfd,0x8a,0x24,0x00,0x4a,0x35,0x24,
   0x08,0x43,0x4f,0x4d,0x4d,0x45,0x4e,0x54,0x24,0x1c,0x00,0x22,0x00,0x07,0x05,0xfd,
   0x8a,0x22,0x00,0x10,0xc0,0x4a,0x22,0x00,0x07,0x05,0xfd,0x8a,0x24,0x00,0x4a,0x35,
   0x34,0x7e,0x00,0x45,0x0d,0xfe,0x3c,0x00,0xfe,0x3c,0x24,0x03,0x4e,0x4f,0x25,0x1a,
   0x00,0x2d,0x7f,0x0e,0xfe,0x34,0x01,0xfe,0x34,0x24,0x02,0x57,0x54,0x1b,0x00,0x3c,
   0x80,0x20,0x00,0x7d,0x07,0x46,0x49,0x53,0x48,0x42,0x49,0x47,0x84,0x22,0x00,0x01,
   0x22,0x00,0x02,0x4c,0x00,0xfe,0x3c,0x6f,0x24,0x0b,0x20,0x46,0x69,0x73,0x68,0x20,
   0x66,0x6f,0x75,0x6e,0x64,0x71,0x73,0x63,0x51,0xfe,0xbf,0x0d,0xfe,0x6a,0x22,0x00,
   0x01,0x7f,0x22,0x00,0x01,0x05,0xfd,0x8a,0x24,0x00,0x4a,0x7e,0x00,0x15,0x22,0x00,
   0x01,0x12,0xfd,0x8a,0x24,0x0a,0x41,0x4c,0x4c,0x20,0x57,0x41,0x54,0x45,0x52,0x53,
   0x81,0x22,0x00,0x02,0x05,0xfd,0x8a,0x24,0x00,0x4a,0x7e,0x00,0x13,0x22,0x00,0x02,
   0x12,0xfd,0x8a,0x24,0x08,0x41,0x4c,0x4c,0x20,0x46,0x49,0x53,0x48,0x81,0x22,0x00,
   0x03,0x05,0xfd,0x8a,0x24,0x00,0x4a,0x7e,0x00,0x19,0x22,0x00,0x03,0x12,0xfd,0x8a,
   0x24,0x0e,0x41,0x4c,0x4c,0x20,0x46,0x4c,0x59,0x53,0x2f,0x42,0x41,0x49,0x54,0x53,
   0x81,0x22,0x00,0x04,0x05,0xfd,0x8a,0x24,0x00,0x4a,0x7e,0x00,0x1b,0x22,0x00,0x04,
   0x12,0xfd,0x8a,0x24,0x10,0x41,0x4c,0x4c,0x20,0x54,0x49,0x4d,0x45,0x53,0x20,0x4f,
   0x46,0x20,0x44,0x41,0x59,0x81,0x22,0x00,0x05,0x05,0xfd,0x8a,0x24,0x00,0x4a,0x7e,
   0x00,0x13,0x22,0x00,0x05,0x12,0xfd,0x8a,0x24,0x08,0x4e,0x4f,0x20,0x54,0x49,0x44,
   0x45,0x53,0x81,0x22,0x00,0x06,0x05,0xfd,0x8a,0x24,0x00,0x4a,0x7e,0x00,0x17,0x22,
   0x00,0x06,0x12,0xfd,0x8a,0x24,0x0c,0x41,0x4c,0x4c,0x20,0x57,0x45,0x41,0x54,0x48,
   0x45,0x52,0x53,0x81,0x22,0x00,0x07,0x05,0xfd,0x8a,0x24,0x00,0x4a,0x7e,0x00,0x15,
   0x22,0x00,0x07,0x12,0xfd,0x8a,0x24,0x0a,0x4e,0x4f,0x20,0x43,0x4f,0x4d,0x4d,0x45,
   0x4e,0x54,0x81,0x0d,0xfd,0x87,0x22,0x00,0x01,0x7f,0x00,0xfd,0x87,0x12,0xfd,0x8a,
   0x00,0xfd,0x87,0x05,0xfd,0x8a,0x20,0x02,0x20,0x01,0x7d,0x07,0x43,0x45,0x4e,0x54,
   0x52,0x45,0x24,0x81,0x0d,0xfd,0x87,0x00,0xfd,0x87,0x22,0x00,0x01,0x2d,0x7f,0x00,
   0xfd,0x87,0x22,0x00,0x08,0x2c,0x7e,0xff,0xd3,0x0d,0xfe,0x6a,0x22,0x00,0x01,0x7f,
   0x00,0xfe,0x6a,0x12,0xfe,0x6d,0x24,0x1f,0x46,0x49,0x53,0x48,0x49,0x4e,0x47,0x20,
   0x52,0x45,0x53,0x55,0x4c,0x54,0x53,0x20,0x20,0x46,0x4f,0x52,0x20,0x46,0x4f,0x4c,
   0x4c,0x4f,0x57,0x49,0x4e,0x47,0x3a,0x81,0x0d,0xfe,0x6a,0x00,0xfe,0x6a,0x22,0x00,
   0x01,0x2d,0x7f,0x00,0xfe,0x6a,0x12,0xfe,0x6d,0x02,0xfd,0x66,0x81,0x0d,0xfe,0x6a,
   0x00,0xfe,0x6a,0x22,0x00,0x01,0x2d,0x7f,0x00,0xfe,0x6a,0x12,0xfe,0x6d,0x22,0x00,
   0x01,0x05,0xfd,0x8a,0x22,0x00,0x0f,0xb8,0x4b,0x22,0x00,0x02,0x05,0xfd,0x8a,0x4b,
   0x81,0x0d,0xfe,0x6a,0x00,0xfe,0x6a,0x22,0x00,0x01,0x2d,0x7f,0x00,0xfe,0x6a,0x12,
   0xfe,0x6d,0x22,0x00,0x03,0x05,0xfd,0x8a,0x22,0x00,0x0f,0xb8,0x4b,0x22,0x00,0x04,
   0x05,0xfd,0x8a,0x4b,0x81,0x0d,0xfe,0x6a,0x00,0xfe,0x6a,0x22,0x00,0x01,0x2d,0x7f,
   0x00,0xfe,0x6a,0x12,0xfe,0x6d,0x22,0x00,0x05,0x05,0xfd,0x8a,0x22,0x00,0x0f,0xb8,
   0x4b,0x22,0x00,0x06,0x05,0xfd,0x8a,0x4b,0x81,0x0d,0xfe,0x6a,0x00,0xfe,0x6a,0x22,
   0x00,0x01,0x2d,0x7f,0x00,0xfe,0x6a,0x12,0xfe,0x6d,0x24,0x0b,0x20,0x20,0x20,0x20,
   0x43,0x4f,0x4d,0x4d,0x45,0x4e,0x54,0x22,0x00,0x0f,0xb8,0x4b,0x22,0x00,0x07,0x05,
   0xfd,0x8a,0x4b,0x81,0x0d,0xfe,0x6a,0x00,0xfe,0x6a,0x22,0x00,0x01,0x2d,0x7f,0x00,
   0xfe,0x6a,0x12,0xfe,0x6d,0x24,0x0d,0x4e,0x4f,0x2e,0x4f,0x46,0x20,0x46,0x49,0x53,
   0x48,0x20,0x3d,0x20,0x22,0x00,0x0f,0xb8,0x4b,0x00,0xfe,0x3c,0x86,0x22,0x00,0x00,
   0x22,0x00,0x06,0xbb,0x4b,0x81,0x0d,0xfe,0x6a,0x00,0xfe,0x6a,0x22,0x00,0x01,0x2d,
   0x7f,0x00,0xfe,0x6a,0x12,0xfe,0x6d,0x24,0x0b,0x54,0x4f,0x54,0x41,0x4c,0x20,0x57,
   0x54,0x20,0x3d,0x20,0x22,0x00,0x0f,0xb8,0x4b,0x01,0xfe,0x34,0x22,0x00,0x02,0x22,
   0x00,0x08,0xbb,0x4b,0x81,0x0d,0xfe,0x6a,0x00,0xfe,0x6a,0x22,0x00,0x01,0x2d,0x7f,
   0x00,0xfe,0x3c,0x22,0x00,0x00,0x29,0x7e,0x00,0x2e,0x00,0xfe,0x6a,0x12,0xfe,0x6d,
   0x24,0x0b,0x41,0x56,0x45,0x52,0x41,0x47,0x45,0x20,0x57,0x54,0x3d,0x22,0x00,0x0f,
   0xb8,0x4b,0x01,0xfe,0x34,0x00,0xfe,0x3c,0x86,0x3f,0x22,0x00,0x02,0x22,0x00,0x08,
   0xbb,0x4b,0x81,0x51,0x00,0x1f,0x00,0xfe,0x6a,0x12,0xfe,0x6d,0x24,0x0b,0x41,0x56,
   0x45,0x52,0x41,0x47,0x45,0x20,0x57,0x54,0x3d,0x22,0x00,0x0f,0xb8,0x4b,0x24,0x01,
   0x30,0x4b,0x81,0x0d,0xfe,0x6a,0x00,0xfe,0x6a,0x22,0x00,0x01,0x2d,0x7f,0x00,0xfe,
   0x6a,0x12,0xfe,0x6d,0x24,0x0a,0x42,0x45,0x53,0x54,0x20,0x46,0x49,0x53,0x48,0x3d,
   0x01,0xfe,0x62,0x22,0x00,0x01,0x22,0x00,0x05,0xbb,0x4b,0x22,0x00,0x0f,0xb8,0x4b,
   0x02,0xfe,0x51,0x4b,0x81,0x00,0xfe,0x3c,0x22,0x00,0x00,0x2c,0x7e,0x00,0x17,0x22,
   0x00,0x05,0x20,0x00,0x20,0x01,0x7d,0x08,0x46,0x49,0x53,0x48,0x4d,0x45,0x53,0x53,
   0x84,0x51,0x00,0x14,0x22,0x00,0x0c,0x20,0x00,0x20,0x01,0x7d,0x08,0x46,0x49,0x53,
   0x48,0x4d,0x45,0x53,0x53,0x84,0x4e,0x20,0x00,0x7d,0x06,0x52,0x45,0x53,0x55,0x4c,
   0x54,0x84,0x7b,0x00,0x00,0x09,0x83,0x50,0x41,0x43,0x4b,0x49,0x4e,0x20,0x20,0x00,
   0x02,0x80,0x00,0x59,0x00,0x55,0x00,0x06,0x00,0x43,0x00,0x00,0x00,0x00,0x05,0x03,
   0x44,0x52,0x24,0x02,0x00,0x00,0x00,0x00,0x0d,0xff,0xfa,0x24,0x18,0x41,0x2d,0x52,
   0x41,0x4d,0x2c,0x42,0x2d,0x50,0x41,0x43,0x4b,0x2c,0x43,0x2d,0x50,0x41,0x43,0x4b,
   0x2c,0x51,0x55,0x49,0x54,0x98,0x7f,0x00,0xff,0xfa,0x22,0x00,0x00,0x2c,0x7e,0x00,
   0x03,0x7b,0x16,0xff,0xfc,0x22,0x00,0x41,0x00,0xff,0xfa,0x2d,0x22,0x00,0x01,0x2e,
   0xb8,0x24,0x01,0x3a,0x4b,0x81,0x00,0xff,0xfa,0x86,0x79,0x00,0x00,0x09,0x83,0x45,
   0x58,0x49,0x53,0x54,0x24,0x20,0x20,0x00,0x02,0x80,0x00,0x57,0x00,0x53,0x00,0x16,
   0x00,0x3f,0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x06,0xff,0xf8,0x02,0xff,0xec,0x0a,
   0x00,0x00,0x0f,0xff,0xf9,0x00,0xff,0xea,0x22,0x00,0x41,0x2d,0xb8,0x24,0x01,0x3a,
   0x4b,0x81,0x02,0xff,0xf9,0x09,0xff,0xfc,0x4b,0xa4,0x7e,0x00,0x0d,0x0f,0xff,0xed,
   0x02,0xff,0xf9,0x09,0xff,0xfc,0x4b,0x81,0x0d,0xff,0xea,0x00,0xff,0xea,0x22,0x00,
   0x01,0x2d,0x7f,0x00,0xff,0xea,0x22,0x00,0x03,0x2c,0x7e,0xff,0xc7,0x02,0xff,0xed,
   0x79,0x00,0x00,0x09,0x83,0x52,0x45,0x53,0x55,0x4c,0x54,0x20,0x20,0x00,0x02,0x80,
   0x00,0xc4,0x00,0xc0,0x00,0x0a,0x00,0xab,0x00,0x00,0x00,0x00,0x08,0x02,0x52,0x24,
   0x05,0x02,0x43,0x25,0x00,0x00,0x00,0x00,0x00,0x0d,0xff,0xf8,0x22,0x00,0x01,0x7f,
   0x4e,0x24,0x04,0x55,0x53,0x45,0x20,0x71,0x22,0x00,0x06,0xb8,0x71,0x24,0x05,0x20,
   0x41,0x4e,0x44,0x20,0x71,0x22,0x00,0x07,0xb8,0x71,0x22,0x00,0x0f,0xb8,0x71,0x24,
   0x0b,0x63,0x6c,0x65,0x61,0x72,0x20,0x3d,0x20,0x65,0x6e,0x64,0x71,0x73,0x22,0x00,
   0x1e,0x54,0x4e,0x00,0xff,0xf8,0x0c,0xff,0xfc,0x71,0x73,0x0d,0xff,0xf6,0x91,0x7f,
   0x00,0xff,0xf6,0x22,0x00,0x01,0x2c,0x7e,0x00,0x06,0x7b,0x51,0x00,0x2f,0x00,0xff,
   0xf6,0x22,0x00,0x03,0x2c,0x7e,0x00,0x10,0x0d,0xff,0xf8,0x00,0xff,0xf8,0x22,0x00,
   0x01,0x2e,0x7f,0x51,0x00,0x17,0x00,0xff,0xf6,0x22,0x00,0x04,0x2c,0x7e,0x00,0x0d,
   0x0d,0xff,0xf8,0x00,0xff,0xf8,0x22,0x00,0x01,0x2d,0x7f,0x00,0xff,0xf8,0x22,0x00,
   0x01,0x27,0x7e,0x00,0x0c,0x0d,0xff,0xf8,0x22,0x00,0x01,0x7f,0x51,0x00,0x13,0x00,
   0xff,0xf8,0x07,0xff,0xfa,0x29,0x7e,0x00,0x09,0x0d,0xff,0xf8,0x07,0xff,0xfa,0x7f,
   0x51,0xff,0x91,0x7b,0x00,0x00,0x09,0x83,0x46,0x49,0x53,0x48,0x42,0x49,0x47,0x20,
   0x00,0x02,0x80,0x00,0x41,0x00,0x3d,0x00,0x06,0x00,0x24,0x00,0x00,0x00,0x00,0x0c,
   0x03,0x42,0x49,0x47,0x01,0x05,0x42,0x44,0x41,0x59,0x24,0x02,0x00,0x00,0x00,0x00,
   0x24,0x02,0x57,0x54,0x1b,0x00,0x08,0xff,0xfc,0x38,0x7e,0x00,0x18,0x15,0xff,0xfc,
   0x24,0x02,0x57,0x54,0x1b,0x00,0x80,0x16,0xff,0xfa,0x24,0x04,0x44,0x41,0x59,0x24,
   0x1c,0x00,0x81,0x7b,0x00,0x00,0x09,0x83,0x46,0x49,0x53,0x48,0x4d,0x45,0x53,0x53,
   0x00,0x02,0x80,0x02,0xa6,0x02,0xa2,0x01,0x99,0x02,0x85,0x01,0x00,0x00,0x00,0x00,
   0x08,0x02,0x43,0x25,0x00,0x02,0x52,0x24,0x05,0x00,0x03,0xfe,0x69,0x20,0x00,0x04,
   0xfe,0x6a,0x00,0x0c,0x22,0x00,0x01,0x12,0xfe,0x6a,0x24,0x0e,0x20,0x57,0x68,0x61,
   0x74,0x21,0x20,0x4e,0x6f,0x20,0x66,0x69,0x73,0x68,0x22,0x00,0x0f,0xb8,0x4b,0x24,
   0x05,0x20,0x20,0x20,0x20,0x20,0x4b,0x22,0x00,0xb5,0xb8,0x22,0x00,0x05,0xc5,0x4b,
   0x81,0x22,0x00,0x02,0x12,0xfe,0x6a,0x24,0x0e,0x4e,0x6f,0x74,0x20,0x6d,0x75,0x63,
   0x68,0x20,0x6c,0x75,0x63,0x6b,0x21,0x22,0x00,0x0f,0xb8,0x4b,0x24,0x05,0x20,0x20,
   0x20,0x20,0x20,0x4b,0x22,0x00,0xb3,0xb8,0x22,0x00,0x05,0xc5,0x4b,0x81,0x22,0x00,
   0x03,0x12,0xfe,0x6a,0x24,0x0c,0x20,0x20,0x54,0x72,0x79,0x20,0x61,0x67,0x61,0x69,
   0x6e,0x21,0x22,0x00,0x0f,0xb8,0x4b,0x24,0x05,0x20,0x20,0x20,0x20,0x20,0x4b,0x24,
   0x01,0x3a,0x22,0x00,0x05,0xc5,0x4b,0x81,0x22,0x00,0x04,0x12,0xfe,0x6a,0x24,0x0f,
   0x43,0x68,0x61,0x6e,0x67,0x65,0x20,0x79,0x6f,0x75,0x72,0x20,0x72,0x6f,0x64,0x22,
   0x00,0x0f,0xb8,0x4b,0x24,0x05,0x20,0x20,0x20,0x20,0x20,0x4b,0x22,0x00,0xb2,0xb8,
   0x22,0x00,0x05,0xc5,0x4b,0x81,0x22,0x00,0x05,0x12,0xfe,0x6a,0x24,0x0d,0x20,0x20,
   0x47,0x6f,0x6f,0x64,0x20,0x43,0x61,0x74,0x63,0x68,0x20,0x22,0x00,0x0f,0xb8,0x4b,
   0x24,0x05,0x20,0x20,0x20,0x20,0x20,0x4b,0x22,0x00,0xfb,0xb8,0x22,0x00,0x05,0xc5,
   0x4b,0x81,0x22,0x00,0x06,0x12,0xfe,0x6a,0x24,0x0d,0x20,0x20,0x51,0x75,0x69,0x74,
   0x65,0x20,0x61,0x20,0x62,0x61,0x67,0x22,0x00,0x0f,0xb8,0x4b,0x24,0x05,0x20,0x20,
   0x20,0x20,0x20,0x4b,0x22,0x00,0xfc,0xb8,0x22,0x00,0x05,0xc5,0x4b,0x81,0x22,0x00,
   0x07,0x12,0xfe,0x6a,0x24,0x0d,0x20,0x20,0x54,0x69,0x67,0x68,0x74,0x20,0x6c,0x69,
   0x6e,0x65,0x73,0x22,0x00,0x0f,0xb8,0x4b,0x24,0x05,0x20,0x20,0x20,0x20,0x20,0x4b,
   0x22,0x00,0xb2,0xb8,0x22,0x00,0x05,0xc5,0x4b,0x81,0x22,0x00,0x08,0x12,0xfe,0x6a,
   0x24,0x0f,0x4b,0x65,0x65,0x70,0x20,0x74,0x68,0x65,0x20,0x72,0x6f,0x64,0x20,0x75,
   0x70,0x22,0x00,0x0f,0xb8,0x4b,0x24,0x05,0x20,0x20,0x20,0x20,0x20,0x4b,0x24,0x01,
   0x2f,0x22,0x00,0x05,0xc5,0x4b,0x81,0x22,0x00,0x09,0x12,0xfe,0x6a,0x24,0x0f,0x20,
   0x20,0x2a,0x2a,0x20,0x57,0x4f,0x57,0x21,0x20,0x2a,0x2a,0x20,0x20,0x20,0x22,0x00,
   0x0f,0xb8,0x4b,0x24,0x05,0x20,0x20,0x20,0x20,0x20,0x4b,0x24,0x01,0x2a,0x22,0x00,
   0x05,0xc5,0x4b,0x81,0x22,0x00,0x0a,0x12,0xfe,0x6a,0x24,0x0e,0x20,0x4f,0x69,0x6c,
   0x20,0x79,0x6f,0x75,0x72,0x20,0x72,0x65,0x65,0x6c,0x22,0x00,0x0f,0xb8,0x4b,0x24,
   0x05,0x20,0x20,0x20,0x20,0x20,0x4b,0x22,0x00,0xef,0xb8,0x22,0x00,0x05,0xc5,0x4b,
   0x81,0x22,0x00,0x0b,0x12,0xfe,0x6a,0x24,0x10,0x53,0x68,0x61,0x72,0x70,0x65,0x6e,
   0x20,0x79,0x6f,0x75,0x20,0x68,0x6f,0x6f,0x6b,0x22,0x00,0x0f,0xb8,0x4b,0x24,0x05,
   0x20,0x20,0x20,0x20,0x20,0x4b,0x22,0x00,0xd2,0xb8,0x22,0x00,0x05,0xc5,0x4b,0x81,
   0x22,0x00,0x0c,0x12,0xfe,0x6a,0x24,0x0e,0x20,0x20,0x48,0x65,0x61,0x74,0x20,0x74,
   0x68,0x65,0x20,0x70,0x61,0x6e,0x22,0x00,0x0f,0xb8,0x4b,0x24,0x05,0x20,0x20,0x20,
   0x20,0x20,0x4b,0x22,0x00,0xdb,0xb8,0x22,0x00,0x05,0xc5,0x4b,0x81,0x0d,0xfe,0x67,
   0x22,0x00,0x63,0x7f,0x00,0xfe,0x67,0x22,0x00,0x0c,0x29,0x00,0xfe,0x67,0x22,0x00,
   0x01,0x27,0x35,0x7e,0x00,0x37,0x07,0xff,0xfc,0x22,0x00,0x05,0x2c,0x7e,0x00,0x1a,
   0x0d,0xfe,0x67,0x22,0x00,0x01,0x86,0xb1,0x07,0xff,0xfc,0x86,0x3e,0x3c,0x22,0x00,
   0x01,0x86,0x3d,0x87,0x7f,0x51,0x00,0x12,0x0d,0xfe,0x67,0x22,0x00,0x05,0x86,0xb1,
   0x07,0xff,0xfc,0x86,0x3e,0x3c,0x87,0x7f,0x51,0xff,0xbb,0x14,0xff,0xfa,0x07,0xff,
   0xfa,0x22,0x00,0x01,0x2d,0x7f,0x07,0xff,0xfa,0x19,0xff,0xf8,0x00,0xfe,0x67,0x05,
   0xfe,0x6a,0x22,0x00,0x10,0xb8,0x4b,0x81,0x7b,0x00,0x00,0x09,0x83,0x43,0x45,0x4e,
   0x54,0x52,0x45,0x24,0x20,0x00,0x02,0x80,0x00,0x33,0x00,0x2f,0x00,0x16,0x00,0x1e,
   0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x03,0xff,0xea,0x10,0x00,0x00,0x0f,0xff,0xeb,
   0x24,0x01,0x20,0x22,0x00,0x10,0x09,0xff,0xfc,0x96,0x2e,0x86,0x94,0x22,0x00,0x02,
   0x30,0xc5,0x09,0xff,0xfc,0x4b,0x81,0x02,0xff,0xeb,0x79,0x00,0x00,0x09,0x83,0x4d,
   0x41,0x44,0x55,0x44,0x47,0x20,0x20,0x00,0x02,0x80,0x00,0xce,0x00,0xca,0x00,0x16,
   0x00,0xb9,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0xff,0xec,0x00,0x08,0x22,
   0x00,0x01,0x10,0xff,0xec,0x22,0x00,0x04,0x7f,0x22,0x00,0x02,0x10,0xff,0xec,0x22,
   0x00,0x0e,0x7f,0x22,0x00,0x03,0x10,0xff,0xec,0x22,0x00,0x15,0x7f,0x22,0x00,0x04,
   0x10,0xff,0xec,0x22,0x00,0x04,0x7f,0x22,0x00,0x05,0x10,0xff,0xec,0x22,0x00,0x04,
   0x7f,0x22,0x00,0x06,0x10,0xff,0xec,0x22,0x00,0x04,0x7f,0x22,0x00,0x07,0x10,0xff,
   0xec,0x22,0x00,0x04,0x7f,0x22,0x01,0x80,0x22,0x00,0x40,0x22,0x00,0x06,0x22,0x00,
   0x07,0x34,0x22,0x00,0x08,0x2f,0x2d,0x55,0x0d,0xff,0xea,0x22,0x00,0x01,0x7f,0x22,
   0x01,0x81,0x00,0xff,0xea,0x03,0xff,0xec,0x55,0x0d,0xff,0xea,0x00,0xff,0xea,0x22,
   0x00,0x01,0x2d,0x7f,0x00,0xff,0xea,0x22,0x00,0x08,0x2c,0x7e,0xff,0xe3,0x22,0x01,
   0x80,0x22,0x00,0x40,0x22,0x00,0x07,0x22,0x00,0x07,0x34,0x22,0x00,0x08,0x2f,0x2d,
   0x55,0x0d,0xff,0xea,0x22,0x00,0x07,0x7f,0x22,0x01,0x81,0x00,0xff,0xea,0x03,0xff,
   0xec,0x55,0x0d,0xff,0xea,0x00,0xff,0xea,0x22,0x00,0x01,0x2e,0x7f,0x00,0xff,0xea,
   0x22,0x00,0x00,0x2c,0x7e,0xff,0xe3,0x7b,0x00,0x00,0x09,0x83,0x55,0x54,0x44,0x49,
   0x52,0x20,0x20,0x20,0x00,0x02,0x80,0x00,0xfc,0x00,0xf8,0x00,0x16,0x00,0xe5,0x00,
   0x00,0x00,0x00,0x00,0x00,0x06,0xff,0xf6,0x02,0xff,0xea,0x0a,0x00,0x00,0x53,0x00,
   0x25,0x0d,0xff,0xfa,0x22,0x00,0x00,0x7f,0x0d,0xff,0xfa,0x00,0xff,0xfa,0x22,0x00,
   0x01,0x2d,0x7f,0x00,0xff,0xfa,0x22,0x00,0x03,0x29,0x7e,0x00,0x09,0x0d,0xff,0xfa,
   0x22,0x00,0x01,0x7f,0x0f,0xff,0xf7,0x22,0x00,0x40,0x00,0xff,0xfa,0x2d,0xb8,0x24,
   0x01,0x3a,0x4b,0x81,0x4e,0x4f,0x01,0x24,0x0e,0x20,0x53,0x45,0x45,0x20,0x46,0x49,
   0x4c,0x45,0x53,0x20,0x4f,0x4e,0x20,0x71,0x22,0x00,0x0f,0xb8,0x71,0x24,0x09,0x20,
   0x20,0x20,0x44,0x52,0x49,0x56,0x45,0x20,0x71,0x02,0xff,0xf7,0x71,0x0d,0xff,0xfc,
   0x91,0x7f,0x00,0xff,0xfc,0x22,0x00,0x02,0x2c,0x7e,0x00,0x08,0x51,0xff,0x9b,0x51,
   0x00,0x6d,0x00,0xff,0xfc,0x22,0x00,0x01,0x2c,0x7e,0x00,0x08,0x51,0x00,0x60,0x51,
   0x00,0x5d,0x00,0xff,0xfc,0x22,0x00,0x0d,0x2c,0x7e,0x00,0x50,0x4e,0x0f,0xff,0xeb,
   0x02,0xff,0xf7,0xb7,0x81,0x02,0xff,0xeb,0x71,0x73,0x02,0xff,0xeb,0x24,0x00,0x4a,
   0x7e,0x00,0x1a,0x24,0x0f,0x2a,0x2a,0x45,0x4e,0x44,0x20,0x4f,0x46,0x20,0x50,0x41,
   0x43,0x4b,0x2a,0x2a,0x71,0x73,0x91,0x83,0x51,0x00,0x24,0x0f,0xff,0xf7,0x24,0x00,
   0x81,0x0d,0xff,0xfc,0x91,0x7f,0x00,0xff,0xfc,0x22,0x00,0x01,0x2c,0x02,0xff,0xeb,
   0x24,0x00,0x4a,0x35,0x7e,0xff,0xb8,0x51,0x00,0x05,0x51,0xff,0x49,0x4f,0x00,0x53,
   0x00,0x00,0x7b,0x00,0x00,0x09,0x83,0x55,0x54,0x42,0x59,0x54,0x45,0x20,0x20,0x00,
   0x02,0x80,0x00,0xd0,0x00,0xcc,0x00,0x0a,0x00,0xbc,0x00,0x00,0x00,0x00,0x00,0x00,
   0x03,0xff,0xf6,0x02,0x00,0x00,0x53,0x00,0x25,0x0d,0xff,0xfc,0x22,0x00,0x00,0x7f,
   0x0d,0xff,0xfc,0x00,0xff,0xfc,0x22,0x00,0x01,0x2d,0x7f,0x00,0xff,0xfc,0x22,0x00,
   0x03,0x29,0x7e,0x00,0x09,0x0d,0xff,0xfc,0x22,0x00,0x01,0x7f,0x0f,0xff,0xf7,0x22,
   0x00,0x40,0x00,0xff,0xfc,0x2d,0xb8,0x81,0x4e,0x4f,0x01,0x4e,0x24,0x0e,0x53,0x50,
   0x41,0x43,0x45,0x20,0x4f,0x4e,0x20,0x44,0x52,0x49,0x56,0x45,0x71,0x73,0x02,0xff,
   0xf7,0x71,0x24,0x01,0x3a,0x71,0x0d,0xff,0xfa,0x91,0x7f,0x00,0xff,0xfa,0x22,0x00,
   0x02,0x2c,0x7e,0x00,0x08,0x51,0xff,0xaa,0x51,0x00,0x47,0x00,0xff,0xfa,0x22,0x00,
   0x01,0x2c,0x7e,0x00,0x0b,0x53,0x00,0x00,0x4f,0x00,0x7b,0x51,0x00,0x34,0x00,0xff,
   0xfa,0x22,0x00,0x0d,0x2c,0x7e,0x00,0x2a,0x02,0xff,0xf7,0x24,0x05,0x3a,0x4d,0x41,
   0x49,0x4e,0x4b,0x65,0x01,0x02,0x02,0x54,0x24,0x88,0x22,0x00,0x04,0x22,0x00,0x02,
   0x4c,0x24,0x03,0x20,0x3d,0x20,0x71,0xb6,0x70,0x73,0x0d,0xff,0xfa,0x91,0x7f,0x5c,
   0x00,0xff,0xfa,0x22,0x00,0x01,0x2c,0x7e,0x00,0x06,0x7b,0x51,0x00,0x05,0x51,0xff,
   0x6d,0x7b,0x00,0x00,0x09,0x83,0x55,0x54,0x44,0x45,0x4c,0x20,0x20,0x20,0x00,0x02,
   0x80,0x01,0x3a,0x01,0x36,0x00,0x16,0x01,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x09,
   0xff,0xf0,0x0a,0xff,0xed,0x01,0xff,0xea,0x01,0x00,0x00,0x53,0x01,0x1b,0x4e,0x24,
   0x0f,0x44,0x45,0x4c,0x45,0x54,0x45,0x20,0x41,0x20,0x46,0x49,0x4c,0x45,0x3f,0x3f,
   0x71,0x73,0x24,0x0e,0x43,0x4f,0x4e,0x54,0x49,0x4e,0x55,0x45,0x20,0x28,0x59,0x2f,
   0x4e,0x29,0x71,0x73,0x0f,0xff,0xee,0xbd,0xc7,0x81,0x02,0xff,0xee,0x24,0x01,0x59,
   0x49,0x7e,0x00,0x05,0x51,0x00,0xe2,0x4e,0x24,0x0f,0x45,0x4e,0x54,0x45,0x52,0x20,
   0x46,0x49,0x4c,0x45,0x20,0x4e,0x41,0x4d,0x45,0x71,0x73,0x0f,0xff,0xf1,0x6e,0x4e,
   0x0f,0xff,0xeb,0x02,0xff,0xf1,0x22,0x00,0x01,0xc0,0xc7,0x81,0x02,0xff,0xf1,0x24,
   0x00,0x4a,0x7e,0x00,0x08,0x51,0x00,0xb1,0x51,0x00,0xab,0x02,0xff,0xeb,0x24,0x01,
   0x41,0x45,0x02,0xff,0xeb,0x24,0x01,0x43,0x47,0x35,0x02,0xff,0xf1,0x22,0x00,0x02,
   0x22,0x00,0x01,0xc2,0x24,0x01,0x3a,0x49,0x35,0x7e,0x00,0x1d,0x24,0x0f,0x49,0x4e,
   0x43,0x4f,0x52,0x52,0x45,0x43,0x54,0x20,0x45,0x4e,0x54,0x52,0x59,0x71,0x73,0x91,
   0x83,0x51,0x00,0x75,0x51,0x00,0x6f,0x02,0xff,0xf1,0xa4,0x7e,0x00,0x54,0x4e,0x02,
   0xff,0xf1,0x71,0x22,0x00,0x0f,0xb8,0x71,0x24,0x0e,0x54,0x4f,0x20,0x42,0x45,0x20,
   0x44,0x45,0x4c,0x45,0x54,0x45,0x44,0x3f,0x71,0x73,0x0d,0xff,0xfc,0x91,0x7f,0x00,
   0xff,0xfc,0x22,0x00,0x0d,0x2b,0x7e,0x00,0x05,0x51,0x00,0x3d,0x02,0xff,0xf1,0x5f,
   0x4e,0x02,0xff,0xf1,0x71,0x22,0x00,0x0f,0xb8,0x71,0x24,0x0d,0x20,0x20,0x4e,0x4f,
   0x57,0x20,0x44,0x45,0x4c,0x45,0x54,0x45,0x44,0x71,0x73,0x91,0x83,0x51,0x00,0x16,
   0x24,0x0e,0x46,0x49,0x4c,0x45,0x20,0x4e,0x4f,0x54,0x20,0x46,0x4f,0x55,0x4e,0x44,
   0x71,0x73,0x91,0x83,0x51,0x00,0x02,0x53,0x00,0x00,0x7b,0x00,0x00,0x09,0x83,0x55,
   0x54,0x49,0x4c,0x53,0x20,0x20,0x20,0x00,0x02,0x80,0x00,0xdd,0x00,0xd9,0x00,0x04,
   0x00,0xcc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0d,0xff,0xfc,0x24,0x20,
   0x43,0x4f,0x4e,0x56,0x45,0x52,0x54,0x2c,0x53,0x50,0x41,0x43,0x45,0x2c,0x46,0x49,
   0x4c,0x45,0x53,0x2c,0x53,0x4f,0x55,0x4e,0x44,0x2c,0x44,0x45,0x4c,0x45,0x54,0x45,
   0x98,0x7f,0x00,0xff,0xfc,0x22,0x00,0x01,0x2c,0x7e,0x00,0x0f,0x20,0x00,0x7d,0x05,
   0x55,0x43,0x4f,0x4e,0x56,0x84,0x51,0x00,0x8c,0x00,0xff,0xfc,0x22,0x00,0x02,0x2c,
   0x7e,0x00,0x10,0x20,0x00,0x7d,0x06,0x55,0x54,0x42,0x59,0x54,0x45,0x84,0x51,0x00,
   0x74,0x00,0xff,0xfc,0x22,0x00,0x03,0x2c,0x7e,0x00,0x0f,0x20,0x00,0x7d,0x05,0x55,
   0x54,0x44,0x49,0x52,0x84,0x51,0x00,0x5d,0x00,0xff,0xfc,0x22,0x00,0x04,0x2c,0x7e,
   0x00,0x11,0x20,0x00,0x7d,0x07,0x55,0x54,0x4e,0x4f,0x49,0x53,0x45,0x84,0x51,0x00,
   0x44,0x00,0xff,0xfc,0x22,0x00,0x05,0x2c,0x7e,0x00,0x39,0x24,0x0e,0x57,0x41,0x52,
   0x4e,0x49,0x4e,0x47,0x20,0x2d,0x20,0x54,0x48,0x49,0x53,0x71,0x22,0x00,0x0f,0xb8,
   0x71,0x24,0x0c,0x45,0x52,0x41,0x53,0x45,0x53,0x20,0x46,0x49,0x4c,0x45,0x53,0x71,
   0x73,0x22,0x00,0x1e,0x54,0x20,0x00,0x7d,0x05,0x55,0x54,0x44,0x45,0x4c,0x84,0x51,
   0x00,0x03,0x7b,0x51,0xff,0x37,0x7b,0x00,0x00,0x09,0x83,0x55,0x43,0x4f,0x4e,0x56,
   0x20,0x20,0x20,0x00,0x02,0x80,0x01,0xbd,0x01,0xb9,0x00,0x2e,0x01,0xa3,0x00,0x00,
   0x00,0x00,0x00,0x00,0x09,0xff,0xf5,0x05,0xff,0xf1,0x02,0xff,0xda,0x05,0x00,0x00,
   0x53,0x00,0x00,0x0d,0xff,0xfc,0x24,0x13,0x4c,0x42,0x53,0x2d,0x4b,0x49,0x4c,0x4f,
   0x53,0x2c,0x4b,0x49,0x4c,0x4f,0x53,0x2d,0x4c,0x42,0x53,0x98,0x7f,0x22,0x00,0x03,
   0x6a,0x00,0xff,0xfc,0x22,0x00,0x01,0x2c,0x7e,0x00,0x08,0x51,0x00,0x16,0x51,0x00,
   0x13,0x00,0xff,0xfc,0x22,0x00,0x02,0x2c,0x7e,0x00,0x08,0x51,0x00,0xcf,0x51,0x00,
   0x03,0x7b,0x53,0x00,0x00,0x53,0xff,0xfc,0x4e,0x24,0x10,0x45,0x4e,0x54,0x45,0x52,
   0x20,0x4c,0x42,0x53,0x3a,0x20,0x20,0x4f,0x5a,0x53,0x3a,0x71,0x73,0x22,0x00,0x07,
   0x22,0x00,0x02,0x4c,0x0f,0xff,0xf6,0x6e,0x22,0x00,0x0d,0x22,0x00,0x02,0x4c,0x0f,
   0xff,0xf2,0x6e,0x02,0xff,0xf6,0x24,0x00,0x4a,0x7e,0x00,0x09,0x0f,0xff,0xf6,0x24,
   0x01,0x30,0x81,0x02,0xff,0xf2,0x24,0x00,0x4a,0x7e,0x00,0x09,0x0f,0xff,0xf2,0x24,
   0x01,0x30,0x81,0x0e,0xff,0xe9,0x02,0xff,0xf6,0xb5,0x80,0x0e,0xff,0xe1,0x02,0xff,
   0xf2,0xb5,0x80,0x0e,0xff,0xe9,0x01,0xff,0xe9,0x01,0xff,0xe1,0x22,0x00,0x10,0x86,
   0x3f,0x3c,0x80,0x0e,0xff,0xd2,0x01,0xff,0xe9,0x23,0x04,0x92,0x35,0x45,0xff,0x3e,
   0x80,0x4e,0x22,0x00,0x01,0x22,0x00,0x01,0x4c,0x24,0x01,0x20,0x71,0x02,0xff,0xf6,
   0x71,0x24,0x06,0x20,0x4c,0x42,0x53,0x3a,0x20,0x71,0x02,0xff,0xf2,0x71,0x24,0x03,
   0x20,0x4f,0x5a,0x71,0x73,0x22,0x00,0x01,0x22,0x00,0x02,0x4c,0x24,0x02,0x3d,0x20,
   0x71,0x01,0xff,0xd2,0x22,0x00,0x02,0x22,0x00,0x07,0xbb,0x71,0x24,0x06,0x20,0x4b,
   0x49,0x4c,0x4f,0x53,0x71,0x73,0x91,0x83,0x51,0xfe,0xf7,0x53,0x00,0x00,0x53,0xff,
   0xfc,0x4e,0x24,0x0c,0x45,0x4e,0x54,0x45,0x52,0x20,0x4b,0x49,0x4c,0x4f,0x53,0x3a,
   0x71,0x73,0x22,0x00,0x07,0x22,0x00,0x02,0x4c,0x0f,0xff,0xdb,0x6e,0x02,0xff,0xdb,
   0x24,0x00,0x4a,0x7e,0x00,0x09,0x0f,0xff,0xdb,0x24,0x01,0x30,0x81,0x0e,0xff,0xe9,
   0x02,0xff,0xdb,0xb5,0x23,0x05,0x30,0x62,0x04,0x22,0x00,0x3e,0x80,0x0e,0xff,0xe1,
   0x01,0xff,0xe9,0x01,0xff,0xe9,0x94,0x86,0x3d,0x80,0x0e,0xff,0xe1,0x01,0xff,0xe1,
   0x22,0x00,0x10,0x86,0x3e,0x80,0x4e,0x24,0x01,0x20,0x71,0x02,0xff,0xdb,0x71,0x24,
   0x06,0x20,0x4b,0x49,0x4c,0x4f,0x53,0x71,0x73,0x24,0x01,0x3d,0x71,0x01,0xff,0xe9,
   0x94,0x6f,0x24,0x06,0x20,0x4c,0x42,0x53,0x3a,0x20,0x71,0x01,0xff,0xe1,0x22,0x00,
   0x00,0x22,0x00,0x02,0xbb,0x71,0x24,0x03,0x20,0x4f,0x5a,0x71,0x73,0x91,0x83,0x51,
   0xfe,0x60,0x7b,0x00,0x00,0x09,0x83,0x55,0x54,0x4e,0x4f,0x49,0x53,0x45,0x20,0x00,
   0x02,0x80,0x00,0x5f,0x00,0x5b,0x00,0x02,0x00,0x4e,0x00,0x00,0x00,0x00,0x00,0x00,
   0x00,0x00,0x00,0x4e,0x24,0x10,0x20,0x53,0x4f,0x55,0x4e,0x44,0x20,0x53,0x57,0x49,
   0x54,0x43,0x48,0x45,0x44,0x20,0x71,0x22,0x00,0xa4,0x9b,0x22,0x00,0x00,0x2c,0x7e,
   0x00,0x1a,0x22,0x00,0xa4,0x22,0x00,0x01,0x55,0x24,0x0a,0x20,0x20,0x20,0x20,0x20,
   0x20,0x20,0x4f,0x46,0x46,0x71,0x73,0x51,0x00,0x16,0x24,0x09,0x20,0x20,0x20,0x20,
   0x20,0x20,0x20,0x4f,0x4e,0x71,0x73,0x22,0x00,0xa4,0x22,0x00,0x00,0x55,0x91,0x83,
   0x7b,0x00,0x00,0xff,0xff,
  };
#endif

////////////////////////////////////////////////////////////////////////////////
//
typedef struct {
  FATFS fatfs;
  char const *const name;
} fatfs_dscr_t;

fatfs_dscr_t fatfs_dscrs[2] = {{.name = "0:"}, {.name = "1:"}};
FATFS *get_fs_by_name(const char *name) {
  for (size_t i = 0; i < count_of(fatfs_dscrs); ++i) {
    if (0 == strcmp(fatfs_dscrs[i].name, name)) {
      return &fatfs_dscrs[i].fatfs;
    }
  }
  return NULL;

}

bool logger_enabled;
const uint32_t period = 1000;
absolute_time_t next_time;

void button_select_file(struct MENU_ELEMENT *e);

////////////////////////////////////////////////////////////////////////////////



// I2C functions
void i2c_release(I2C_PORT_DESC *port);
void i2c_delay(I2C_PORT_DESC *port);
void i2c_sda_low(I2C_PORT_DESC *port);
void i2c_sda_high(I2C_PORT_DESC *port);
void i2c_scl_low(I2C_PORT_DESC *port);
void i2c_scl_high(I2C_PORT_DESC *port);
void i2c_start(I2C_PORT_DESC *port);
void i2c_stop(I2C_PORT_DESC *port);
int i2c_send_byte(I2C_PORT_DESC *port, BYTE b);
int i2c_read_bytes(I2C_SLAVE_DESC *slave, int n, BYTE *data);
void i2c_send_bytes(I2C_SLAVE_DESC *slave, int n, BYTE *data);
#


#endif /* I2C_FUNCTIONS_H_ */


/*
 * i2c_functions.c
 *
 *  Created on: 23 Jul 2016
 *      Author: menadue
 */
//#include "chip.h"
//#include "board.h"
//#include "i2c_functions.h"


// I2C functions

// Release the bus
void i2c_release(I2C_PORT_DESC *port) {
  // All inputs
  gpio_set_dir(SDA_PIN,GPIO_OUT);
  gpio_set_dir(SCL_PIN,GPIO_OUT);
  gpio_put(SDA_PIN, 0);
  gpio_put(SCL_PIN, 0);
  
  //  Chip_GPIO_SetPinDIRInput(LPC_GPIO, port->sdaport, port->sdabit);
  //Chip_GPIO_SetPinDIRInput(LPC_GPIO, port->sclport, port->sclbit);
}

// Delay to slow down to I2C bus rates
void i2c_delay(I2C_PORT_DESC *port) {
  loop_delay(1);
  return;
  volatile int i;
  for(i=0; i<1; i++)
    {
    }
  
}

void i2c_sda_low(I2C_PORT_DESC *port)
{
  // Take SCL low by driving a 0 on to the bus
  gpio_set_dir(SDA_PIN,GPIO_OUT);
  gpio_put(SDA_PIN, 0);
  //Chip_GPIO_SetPinState(LPC_GPIO, port->sdaport, port->sdabit, 0);
  
  // Make sure bit is an output
  //Chip_GPIO_SetPinDIROutput(LPC_GPIO, port->sdaport, port->sdabit);
}

void i2c_sda_high(I2C_PORT_DESC *port)
{
  // Make sure bit is an input
  gpio_set_dir(SDA_PIN,GPIO_IN);
  //  gpio_put(SDA_PIN, 1);
  //  Chip_GPIO_SetPinDIRInput(LPC_GPIO, port->sdaport, port->sdabit);
}

void i2c_scl_low(I2C_PORT_DESC *port) {

  gpio_set_dir(SCL_PIN,GPIO_OUT);
  gpio_put(SCL_PIN, 0);
  
  //  Chip_GPIO_SetPinState(LPC_GPIO, port->sclport, port->sclbit, 0);

  // Make sure bit is an output
  //Chip_GPIO_SetPinDIROutput(LPC_GPIO, port->sclport, port->sclbit);
}

void i2c_scl_high(I2C_PORT_DESC *port)
{
  // Make sure bit is an input
  gpio_set_dir(SCL_PIN, GPIO_IN);
  //gpio_put(SCL_PIN, 1);
  //Chip_GPIO_SetPinDIRInput(LPC_GPIO, port->sclport, port->sclbit);
}

// Read ACK bit

int i2c_read_sda(I2C_PORT_DESC *port)
{
  return(gpio_get(SDA_PIN));
  //  return(Chip_GPIO_GetPinState(LPC_GPIO, port->sdaport, port->sdabit));

  //  return( ((*(port->port)) & (port->sda_mask)) == port->sda_mask);
}

// I2C start condition

void i2c_start(I2C_PORT_DESC *port)
{
  //
  i2c_sda_low(port);

  i2c_delay(port);
  i2c_scl_low(port);
  i2c_delay(port);
}

void i2c_stop(I2C_PORT_DESC *port)
{
  i2c_scl_high(port);
  i2c_delay(port);
  i2c_sda_high(port);
  i2c_delay(port);

}

// Send 8 bits and read ACK
// Returns number of acks received

int i2c_send_byte(I2C_PORT_DESC *port, BYTE b)
{
  int i;
  int ack=0;
  int retries = 100;
  int rc =1;

  for (i = 0; i < 8; i++)
    {
      // Set up data
      if ((b & 0x80) == 0x80)
	{
	  i2c_sda_high(port);
	} else
	{
	  i2c_sda_low(port);
	}

      // Delay
      i2c_delay(port);

      // Take clock high and then low
      i2c_scl_high(port);

      // Delay
      i2c_delay(port);

      // clock low again
      i2c_scl_low(port);

      // Delay
      i2c_delay(port);

      // Shift next data bit in
      b <<= 1;
    }

  // release data line
  i2c_sda_high(port);

  // Now get ACK
  i2c_scl_high(port);

  i2c_delay(port);

  // read ACK

  while( ack = i2c_read_sda(port) ) // @suppress("Assignment in condition")
    {
      retries--;

      if ( retries == 0 )
	{
	  rc = 0;
	  break;
	}
    }

  i2c_scl_low(port);

  i2c_delay(port);
  return (rc);
}


// Receive 8 bits and set ACK
// Ack as specified
void i2c_recv_byte(I2C_PORT_DESC *port, BYTE *data, int ack)
{
  int i, b;

  b = 0;

  // Make data an input
  i2c_sda_high(port);

  for (i = 0; i < 8; i++)
    {
      // Delay
      i2c_delay(port);

      // Take clock high and then low
      i2c_scl_high(port);

      // Delay
      i2c_delay(port);

      // Shift next data bit in
      b <<= 1;
      b += (i2c_read_sda(port) & 0x1);

      // clock low again
      i2c_scl_low(port);

      // Delay
      i2c_delay(port);

    }

  // ACK is as we are told 
  if ( ack )
    {
      // Data low for ACK
      i2c_sda_low(port);
    }
  else
    {
      i2c_sda_high(port);
    }

  // Now send ACK
  i2c_scl_high(port);

  i2c_delay(port);

  i2c_scl_low(port);

  i2c_delay(port);

  *data = b;

}

// Reads a block of bytes from a slave

int i2c_read_bytes(I2C_SLAVE_DESC *slave, int n, BYTE *data)
{
  int i;
  BYTE byte;

  i2c_start(slave->port);

  // Send slave address with read bit
  if ( !i2c_send_byte(slave->port, ((slave->slave_7bit_addr) << 1) | 1) )
    {
      i2c_stop(slave->port);
      return(0);
    }


  //
  for (i = 0; i < n; i++)
    {
      i2c_recv_byte(slave->port, &byte, (i==(n-1))? 0 : 1);
      *(data++) = byte;
    }

  i2c_stop(slave->port);

  return(1);
}

// Sends a block of data to I2C slave
void i2c_send_bytes(I2C_SLAVE_DESC *slave, int n, BYTE *data)
{
  int i;

  i2c_start(slave->port);

  // Send slave address with read bit
  i2c_send_byte(slave->port, ((slave->slave_7bit_addr) << 1) | 0);

  //
  for (i = 0; i < n; i++)
    {
      i2c_send_byte(slave->port, *(data++));
    }

  i2c_stop(slave->port);
}

void i2c_init(I2C_PORT_DESC *port)
{
  gpio_init(SDA_PIN);
  gpio_init(SCL_PIN);
  //Chip_GPIO_SetPinDIROutput(LPC_GPIO, 0, 19);
  //Chip_GPIO_SetPinDIROutput(LPC_GPIO, 0, 2);
  //Chip_GPIO_SetPinDIROutput(LPC_GPIO, 0, 18);
  //Chip_GPIO_SetPinDIROutput(LPC_GPIO, 0, 7);
  //Chip_GPIO_SetPinDIROutput(LPC_GPIO, 1, 19);
  //Chip_GPIO_SetPinDIROutput(LPC_GPIO, 1, 20);
}

/*
 * oled096.h
 *
 *  Created on: 23 Jul 2016
 *      Author: menadue
 */

#ifndef OLED096_H_
#define OLED096_H_

#define I2C_CMD       1
#define I2C_DATA      0
#define I2C_REPEAT    1
#define I2C_NO_REPEAT 0

void oled_send_cmd(I2C_SLAVE_DESC *slave, int n, const unsigned char *data, int command, int repeat);
void oled_set_xy(I2C_SLAVE_DESC *slave, int x, int y);
void oled_set_pixel_xy(I2C_SLAVE_DESC *slave, int x, int y);
void oled_set_byte_xy(I2C_SLAVE_DESC *slave, int x, int y, int b);
void oled_gap(I2C_SLAVE_DESC *slave);
void oled_display_int(I2C_SLAVE_DESC *slave, long int n, int num_digits);
void oled_display_string(I2C_SLAVE_DESC *slave, char *string);
void oled_clear_display(I2C_SLAVE_DESC *slave);
void oled_printf(I2C_SLAVE_DESC *slave, char *format, ...);

void oled_setup(I2C_SLAVE_DESC *slave);
void oled_display_scaled_string_xy(I2C_SLAVE_DESC *slave, char *string, int x, int y, int scale);

extern const unsigned char font_5x7_letters[];

#endif /* OLED096_H_ */

/*
 * oled096.c
 *
 *  Created on: 23 Jul 2016
 *      Author: menadue
 */

//
// 0.96" OLED display functions
//


// Sends a block of commands to the SSD1306
// command causes 80 to be sent before each byte
// command = 0 causes 0x40 and just data bytes
// Repeat = 1, repeat data byte 0

//#include <string.h>
//#include "i2c_functions.h"
//#include "oled096.h"

void oled_send_cmd(I2C_SLAVE_DESC *slave, int n, const unsigned char *data, int command, int repeat)
{
  int i;

  i2c_start(slave->port);

  // Send slave address
  i2c_send_byte(slave->port, (slave->slave_7bit_addr)<<1);

  if ( !command )
    {
      i2c_send_byte(slave->port, 0x40);
    }

  // Send the command bytes, each preceded bu 0x80 (continuation)
  for (i = 0; i < n; i++) {
    if ( command )
      {
        i2c_send_byte(slave->port, 0x80);
      }
    i2c_send_byte(slave->port, *data);

    if ( !repeat )
      {
	data++;
      }
  }

  i2c_stop(slave->port);
}

//--------------------------------------------------------------------------------
// OLED display functions
//

const unsigned char init_seq[] = {
				  0xae,                       // ???
				  0xd5, 0x80,

				  0xa8,0x3f,

				  0xd3,0x00,
				  0x8d,0x14,0x40,0xa6,0xa4,0xa1,0xc8,0xda,0x12,0x81,0x8f,
				  0xd9,         //??

				  0xf1,0xdb,0x40,0xaf,
};

// From data sheet
const unsigned char init_seq2[] = {
				   //  0xae,          // Display Off
#if PICOPAK
				   0xa8,0x1f,       // MUX ratio works for now
#else
				   0xa8,0x3f,       // MUX ratio works for now
#endif
				   0xd3,0x00,       // Set display offset 0
				   0x40,            // Set display start Line
				   0x8d,0x14,       // Charge pump ON, needed or blank display
				   0xa1,            // Seg remap 180 rotate
				   0xc8,            // Inverted COM scan
#if PICOPAK				   
				   0xda, 0x02,      // COM config: A5:Disable left/right remap, A4:Alternate COM pin config from 12
#else
				   0xda, 0x12,      // COM config: A5:Disable left/right remap, A4:Alternate COM pin config from 12
#endif
				   0x81,0x2f,      // Contrast value
				   //				   0x81,0x2f,      // Contrast value
				   0xd9, 0xf1,     // Precharge, quite important
				   0xdb, 0x40,     // Set Vcomh level, leave it out and inverted display.

				   0xa6,            // Normal display (not inverted)
				   0xd5,0x80,       // Set display oscillator

				   0x20, 0x02,        // Page addressing mode
				   0x21,0x00,0x7f,               // Set display RAM start and end address
				   // seems to have effect in page addressing mode.
				   0x22,0x00,0x07,               // Set display page address

				   0xa4,
				   0xaf,             // Display ON
};

const unsigned char display_setup_seq[] = {
					   0x21,0x00,0x7f,               // Set display RAM start and end address
					   0x22,0x00,0x3f,               // Set display page address
};


const unsigned char display_text_seq[] = {
					  0x7e,0x11,0x11,0x11,0x7e,0x00,0x7f,0x49,0x49,0x49,0x36,0x00,0x00,0x3e,0x41,0x41,0x41,0x22,0x00,0x7f,0x41,0x41,0x41,0x22,0x1c,0x00,0x7f,0x49,0x49,0x49,0x41,0x00,
};

void oled_set_brightness(I2C_SLAVE_DESC *slave, int percent)
{
  unsigned char seq[2];

  seq[0] = 0x81;      // Set contrast (brightness)
  seq[1] = percent * 255 / 100;

  oled_send_cmd(slave, sizeof(seq), &(seq[0]), I2C_CMD, I2C_NO_REPEAT);
}

// Set XY to given position
// We attempt to position to the byte that holds the pixel (x,y)
// Page addressing mode

void oled_set_xy(I2C_SLAVE_DESC *slave, int x, int y)
{
  unsigned char seq[3];

  x = x % 128;
  y = y % 64;
  seq[0] = 0xB0+y/8;      // Set page
  seq[1] = 0x00+x%16;     // Set low part of start address
  seq[2] = 0x10+x/16;     // Set high part

  oled_send_cmd(slave, sizeof(seq), &(seq[0]), I2C_CMD, I2C_NO_REPEAT);
}

unsigned char byteval[1];

// Writes bit pattern at x,y
void oled_set_pixel_xy(I2C_SLAVE_DESC *slave, int x, int y)

{
  byteval[0] = 1<< (y % 8);

  oled_set_xy(slave, x, y);
  oled_send_cmd(slave, 1, &(byteval[0]), I2C_DATA, I2C_NO_REPEAT);
}


////////////////////////////////////////////////////////////////////////////////
// Menu system
//


int but_pins[NUM_BUTTONS] = {SW0_PIN, SW1_PIN, SW2_PIN};


void but_ev_up();
void but_ev_down();
void but_ev_select();
void draw_menu(I2C_SLAVE_DESC *slave, struct MENU_ELEMENT *e, bool clear);


struct MENU_ELEMENT *current_menu;
int file_menu_size = 0;

struct MENU_ELEMENT *last_menu;
struct MENU_ELEMENT *the_home_menu;

int menu_selection = 0;
//unsigned int menu_size = 0;

#define MAX_LISTFILES 200
#define MAX_NAME 20

struct MENU_ELEMENT listfiles[MAX_LISTFILES+1];
int num_listfiles;
char names[MAX_LISTFILES][MAX_NAME];
char current_file[MAX_NAME+1];
int brightness_percent = 100;

// read the file with the given name into the buffer

void core_read(I2C_SLAVE_DESC *slave, char *arg);
void i2c_send_bytes(I2C_SLAVE_DESC *slave, int n, BYTE *data);
#

I2C_PORT_DESC i2c_bus_0 =
  {
   0, 18,
   0, 7,
  };

// Dummy structure
I2C_SLAVE_DESC oled0 =
  {
   &i2c_bus_0,
   0x78 >>1,
  };


void oled_set_byte_xy(I2C_SLAVE_DESC *slave, int x, int y, int b)
{
  byteval[0] = b;

  oled_set_xy(slave, x, y);
  oled_send_cmd(slave, 1, &(byteval[0]), I2C_DATA, I2C_NO_REPEAT);
}


// Font

const unsigned char font_5x7_letters[] = {
					  0x00, 0x00, 0x00, 0x00, 0x00,// (space)
					  0x00, 0x00, 0x5F, 0x00, 0x00,// !
					  0x00, 0x07, 0x00, 0x07, 0x00,// "
					  0x14, 0x7F, 0x14, 0x7F, 0x14,// #
					  0x24, 0x2A, 0x7F, 0x2A, 0x12,// $
					  0x23, 0x13, 0x08, 0x64, 0x62,// %
					  0x36, 0x49, 0x55, 0x22, 0x50,// &
					  0x00, 0x05, 0x03, 0x00, 0x00,// '
					  0x00, 0x1C, 0x22, 0x41, 0x00,// (
					  0x00, 0x41, 0x22, 0x1C, 0x00,// )
					  0x08, 0x2A, 0x1C, 0x2A, 0x08,// *
					  0x08, 0x08, 0x3E, 0x08, 0x08,// +
					  0x00, 0x50, 0x30, 0x00, 0x00,// ,
					  0x08, 0x08, 0x08, 0x08, 0x08,// -
					  0x00, 0x60, 0x60, 0x00, 0x00,// .
					  0x20, 0x10, 0x08, 0x04, 0x02,// /
					  0x3E, 0x51, 0x49, 0x45, 0x3E,// 0
					  0x00, 0x42, 0x7F, 0x40, 0x00,// 1
					  0x42, 0x61, 0x51, 0x49, 0x46,// 2
					  0x21, 0x41, 0x45, 0x4B, 0x31,// 3
					  0x18, 0x14, 0x12, 0x7F, 0x10,// 4
					  0x27, 0x45, 0x45, 0x45, 0x39,// 5
					  0x3C, 0x4A, 0x49, 0x49, 0x30,// 6
					  0x01, 0x71, 0x09, 0x05, 0x03,// 7
					  0x36, 0x49, 0x49, 0x49, 0x36,// 8
					  0x06, 0x49, 0x49, 0x29, 0x1E,// 9
					  0x00, 0x36, 0x36, 0x00, 0x00,// :
					  0x00, 0x56, 0x36, 0x00, 0x00,// ;
					  0x00, 0x08, 0x14, 0x22, 0x41,// <
					  0x14, 0x14, 0x14, 0x14, 0x14,// =
					  0x41, 0x22, 0x14, 0x08, 0x00,// >
					  0x02, 0x01, 0x51, 0x09, 0x06,// ?
					  0x32, 0x49, 0x79, 0x41, 0x3E,// @
					  0x7E, 0x11, 0x11, 0x11, 0x7E,// A
					  0x7F, 0x49, 0x49, 0x49, 0x36,// B
					  0x3E, 0x41, 0x41, 0x41, 0x22,// C
					  0x7F, 0x41, 0x41, 0x22, 0x1C,// D
					  0x7F, 0x49, 0x49, 0x49, 0x41,// E
					  0x7F, 0x09, 0x09, 0x01, 0x01,// F
					  0x3E, 0x41, 0x41, 0x51, 0x32,// G
					  0x7F, 0x08, 0x08, 0x08, 0x7F,// H
					  0x00, 0x41, 0x7F, 0x41, 0x00,// I
					  0x20, 0x40, 0x41, 0x3F, 0x01,// J
					  0x7F, 0x08, 0x14, 0x22, 0x41,// K
					  0x7F, 0x40, 0x40, 0x40, 0x40,// L
					  0x7F, 0x02, 0x04, 0x02, 0x7F,// M
					  0x7F, 0x04, 0x08, 0x10, 0x7F,// N
					  0x3E, 0x41, 0x41, 0x41, 0x3E,// O
					  0x7F, 0x09, 0x09, 0x09, 0x06,// P
					  0x3E, 0x41, 0x51, 0x21, 0x5E,// Q
					  0x7F, 0x09, 0x19, 0x29, 0x46,// R
					  0x46, 0x49, 0x49, 0x49, 0x31,// S
					  0x01, 0x01, 0x7F, 0x01, 0x01,// T
					  0x3F, 0x40, 0x40, 0x40, 0x3F,// U
					  0x1F, 0x20, 0x40, 0x20, 0x1F,// V
					  0x7F, 0x20, 0x18, 0x20, 0x7F,// W
					  0x63, 0x14, 0x08, 0x14, 0x63,// X
					  0x03, 0x04, 0x78, 0x04, 0x03,// Y
					  0x61, 0x51, 0x49, 0x45, 0x43,// Z
					  0x00, 0x00, 0x7F, 0x41, 0x41,// [
					  0x02, 0x04, 0x08, 0x10, 0x20,// "\"
					  0x41, 0x41, 0x7F, 0x00, 0x00,// ]
					  0x04, 0x02, 0x01, 0x02, 0x04,// ^
					  0x40, 0x40, 0x40, 0x40, 0x40,// _
					  0x00, 0x01, 0x02, 0x04, 0x00,// `
					  0x20, 0x54, 0x54, 0x54, 0x78,// a
					  0x7F, 0x48, 0x44, 0x44, 0x38,// b
					  0x38, 0x44, 0x44, 0x44, 0x20,// c
					  0x38, 0x44, 0x44, 0x48, 0x7F,// d
					  0x38, 0x54, 0x54, 0x54, 0x18,// e
					  0x08, 0x7E, 0x09, 0x01, 0x02,// f
					  0x08, 0x14, 0x54, 0x54, 0x3C,// g
					  0x7F, 0x08, 0x04, 0x04, 0x78,// h
					  0x00, 0x44, 0x7D, 0x40, 0x00,// i
					  0x20, 0x40, 0x44, 0x3D, 0x00,// j
					  0x00, 0x7F, 0x10, 0x28, 0x44,// k
					  0x00, 0x41, 0x7F, 0x40, 0x00,// l
					  0x7C, 0x04, 0x18, 0x04, 0x78,// m
					  0x7C, 0x08, 0x04, 0x04, 0x78,// n
					  0x38, 0x44, 0x44, 0x44, 0x38,// o
					  0x7C, 0x14, 0x14, 0x14, 0x08,// p
					  0x08, 0x14, 0x14, 0x18, 0x7C,// q
					  0x7C, 0x08, 0x04, 0x04, 0x08,// r
					  0x48, 0x54, 0x54, 0x54, 0x20,// s
					  0x04, 0x3F, 0x44, 0x40, 0x20,// t
					  0x3C, 0x40, 0x40, 0x20, 0x7C,// u
					  0x1C, 0x20, 0x40, 0x20, 0x1C,// v
					  0x3C, 0x40, 0x30, 0x40, 0x3C,// w
					  0x44, 0x28, 0x10, 0x28, 0x44,// x
					  0x0C, 0x50, 0x50, 0x50, 0x3C,// y
					  0x44, 0x64, 0x54, 0x4C, 0x44,// z
					  0x00, 0x08, 0x36, 0x41, 0x00,// {
					  0x00, 0x00, 0x7F, 0x00, 0x00,// |
					  0x00, 0x41, 0x36, 0x08, 0x00,// }
					  0x08, 0x08, 0x2A, 0x1C, 0x08,// ->
					  0x08, 0x1C, 0x2A, 0x08, 0x08 // <-
};

// Turn display off
const unsigned char off_seq = {
			       0xae
};

// Turn display on
const unsigned char on_seq = {
			      0xaf
};


// Prints a character gap
void oled_gap(I2C_SLAVE_DESC *slave)
{
  unsigned char zero = 0;

  oled_send_cmd(slave, 1, &zero, I2C_DATA, I2C_NO_REPEAT);
}

// Displays an integer in decimal, number of digits displayed is specified, MS digits dropped

void oled_display_int(I2C_SLAVE_DESC *slave, long int n, int num_digits)
{
  int i;
  int dig;
  int mul = 10000;

  if( n < 0 )
    {
      oled_display_string(slave, "-");
      n = -n;
    }
  else
    {
      oled_display_string(slave, " ");
    }

  for(i=5; i>0; i--)
    {
      dig = n / mul;
      n = n % mul;
      mul /=10;

      // Display digit
      if ( i <= num_digits )
	{
	  oled_send_cmd(slave, 5, font_5x7_letters+('0'-' ')*5+dig*5, I2C_DATA, I2C_NO_REPEAT);
	  oled_gap(slave);
	}
    }
}

void oled_display_string(I2C_SLAVE_DESC *slave, char *string)
{
  int j;
  int len = strlen(string);

  for(j=0; j<len; j++)
    {
      oled_send_cmd(slave, 5, font_5x7_letters+((*string++) - ' ')*5, I2C_DATA, I2C_NO_REPEAT);
      oled_gap(slave);
    }
}

void oled_printf(I2C_SLAVE_DESC *slave, char *format, ...)
{
  char buffer[100];
  va_list aptr;
  int ret;
  
  va_start(aptr, format);
  ret = vsprintf(buffer, format, aptr);
  va_end(aptr);
  oled_display_string(slave, buffer);
}

BYTE zero = 0;
void oled_clear_display(I2C_SLAVE_DESC *slave)
{
  int y;

  for(y=0; y<64; y+=8)
    {
      oled_set_xy(slave, 0, y);
      oled_send_cmd(slave, 128, &zero, I2C_DATA, I2C_REPEAT);
    }

}

//
// Displays a string with pixel scaling
//
unsigned char scaled_line[100];

void oled_display_scaled_string_xy(I2C_SLAVE_DESC *slave, char *string, int x, int y, int scale)
{
  unsigned char i;
  int  j, k, s;
  int scale_i;
  int len = strlen(string);
  int b;

  // We now display the string a character at a time, each character being scaled
  scale_i = 0;

  for(k=0; k<len; k++)
    {
      // Scale character
      // We start with 5 bytes, each of 8 bits, these are vertical slices of the bit pattern
      // We need to stretch the character vertically by scale

      for(i=0; i<5; i++)
	{
	  // For each byte we build a new bitmap that is scaled
	  for(j=0; j<8; j++)
	    {
	      // Get next bit
	      b  = (*(font_5x7_letters+((*string)-' ')*5+i));
	      b &= (1 << (7-j));
	      b >>= (7-j);

	      // Shift more bits in to scaled data
	      for(s=0; s<scale;s++)
		{
		  scaled_line[scale_i/8] <<= 1;
		  scaled_line[scale_i/8] |= b;
		  scale_i++;
		}
	    }
#if 0
	  // Move to next byte
	  while( (scale_i % 8) != 0 )
	    {
	      scale_i++;
	    }
#endif
	}

      // Put a gap between chars
      for(s=0; s<scale;s++)
	{
	  scaled_line[scale_i/8] = 0;
	  scale_i+=8;
	}

      string++;
    }

  // Send scaled data to display
  for(j=0; j < scale; j++)
    {
      oled_set_xy(slave, x, y+8*((scale-1)-j));
      for(i=0; i<5*len*scale; i+=scale)
	{
	  for(s=0; s<scale;s++)
	    {
	      oled_send_cmd(slave, 1, &(scaled_line[i+j]), I2C_DATA, I2C_NO_REPEAT);
	    }
	}
      oled_gap(slave);
    }

#if 0
  oled_set_xy(slave, 0,0);
  for(j=0;j<scale_i/8;j++)
    {
      oled_send_cmd(slave, 1, &(scaled_line[j]), I2C_DATA, I2C_NO_REPEAT);
    }


  oled_set_xy(slave, 30, 24);
  oled_display_int(slave, scale_i,5);
  oled_set_xy(slave, 30, 32);
  oled_display_int(slave, len,5);
#endif
}

void oled_error(char *str)
{
  oled_clear_display(&oled0);
  
  oled_set_xy(&oled0, 0,0);
  oled_display_string(&oled0, str);

  loop_delay(3000000);
}

void oled_setup(I2C_SLAVE_DESC *slave)
{
  int i;

  // Release bus
  i2c_release(slave->port);

  // Delay to allow things to start up.
  for(i=0; i<10000; i++)
    {
    }

  // Then clear any glitched I2C commands with a start and stop
  i2c_start(slave->port);
  i2c_stop(slave->port);

  // Initialise display
  oled_send_cmd(slave, sizeof(init_seq2), &(init_seq2[0]), 1, 0);

  // Clear display
  oled_clear_display(slave);


}

void run_setrtc() {
  const char *dateStr = strtok(NULL, " ");
  if (!dateStr) {
    printf("Missing argument\n");
    return;
  }
  int date = atoi(dateStr);

  const char *monthStr = strtok(NULL, " ");
  if (!monthStr) {
    printf("Missing argument\n");
    return;
  }
  int month = atoi(monthStr);

  const char *yearStr = strtok(NULL, " ");
  if (!yearStr) {
    printf("Missing argument\n");
    return;
  }
  int year = atoi(yearStr) + 2000;

  const char *hourStr = strtok(NULL, " ");
  if (!hourStr) {
    printf("Missing argument\n");
    return;
  }
  int hour = atoi(hourStr);

  const char *minStr = strtok(NULL, " ");
  if (!minStr) {
    printf("Missing argument\n");
    return;
  };
  int min = atoi(minStr);

  const char *secStr = strtok(NULL, " ");
  if (!secStr) {
    printf("Missing argument\n");
    return;
  }
  int sec = atoi(secStr);

  datetime_t t = {.year = year,
		  .month = month,
		  .day = date,
		  .dotw = 0,  // 0 is Sunday, so 5 is Friday
		  .hour = hour,
		  .min = min,
		  .sec = sec};
  // bool r = rtc_set_datetime(&t);
  setrtc(&t);
}
void run_lliot() {
  size_t pnum = 0;
  char *arg1 = strtok(NULL, " ");
  if (arg1) {
    pnum = strtoul(arg1, NULL, 0);
  }
  //lliot(pnum);
}
void run_date() {
  char buf[128] = {0};
  time_t epoch_secs = time(NULL);
  struct tm *ptm = localtime(&epoch_secs);
  size_t n = strftime(buf, sizeof(buf), "%c", ptm);
  myASSERT(n);
  printf("%s\n", buf);
  strftime(buf, sizeof(buf), "%j",
	   ptm);  // The day of the year as a decimal number (range
  // 001 to 366).
  printf("Day of year: %s\n", buf);
}
void run_format() {
  char *arg1 = strtok(NULL, " ");
  if (!arg1) {
    printf("Missing argument\n");
    return;
  }
  FATFS *p_fs = get_fs_by_name(arg1);
  if (!p_fs) {
    printf("Unknown logical drive number: \"%s\"\n", arg1);
    return;
  }
  /* Format the drive with default parameters */
  FRESULT fr = f_mkfs(arg1, 0, 0, FF_MAX_SS * 2);
  if (FR_OK != fr) printf("f_mkfs error: %s (%d)\n", FRESULT_str(fr), fr);
}
void run_mount() {
  char *arg1 = strtok(NULL, " ");
  if (!arg1) arg1 = "0:";
  FATFS *p_fs = get_fs_by_name(arg1);
  if (!p_fs) {
    printf("Unknown logical drive number: \"%s\"\n", arg1);
    return;
  }
  FRESULT fr = f_mount(p_fs, arg1, 1);
  if (FR_OK != fr) printf("f_mount error: %s (%d)\n", FRESULT_str(fr), fr);
}
void run_unmount() {
  char *arg1 = strtok(NULL, " ");
  if (!arg1) arg1 = "";
  FRESULT fr = f_unmount(arg1);
  if (FR_OK != fr) printf("f_mount error: %s (%d)\n", FRESULT_str(fr), fr);
}
void run_chdrive() {
  char *arg1 = strtok(NULL, " ");
  if (!arg1) arg1 = "0:";
  FRESULT fr = f_chdrive(arg1);
  if (FR_OK != fr) printf("f_mount error: %s (%d)\n", FRESULT_str(fr), fr);
}
void run_getfree() {
  char *arg1 = strtok(NULL, " ");
  if (!arg1) arg1 = "0:";
  DWORD fre_clust, fre_sect, tot_sect;
  /* Get volume information and free clusters of drive */
  FATFS *p_fs = get_fs_by_name(arg1);
  if (!p_fs) {
    printf("Unknown logical drive number: \"%s\"\n", arg1);
    return;
  }
  FRESULT fr = f_getfree(arg1, &fre_clust, &p_fs);
  if (FR_OK != fr) {
    printf("f_getfree error: %s (%d)\n", FRESULT_str(fr), fr);
    return;
  }
  /* Get total sectors and free sectors */
  tot_sect = (p_fs->n_fatent - 2) * p_fs->csize;
  fre_sect = fre_clust * p_fs->csize;
  /* Print the free space (assuming 512 bytes/sector) */
  printf("%10lu KiB total drive space.\n%10lu KiB available.\n", tot_sect / 2,
	 fre_sect / 2);
}
void run_cd() {
  char *arg1 = strtok(NULL, " ");
  if (!arg1) {
    printf("Missing argument\n");
    return;
  }
  FRESULT fr = f_chdir(arg1);
  if (FR_OK != fr) printf("f_mkfs error: %s (%d)\n", FRESULT_str(fr), fr);
}
void run_mkdir() {
  char *arg1 = strtok(NULL, " ");
  if (!arg1) {
    printf("Missing argument\n");
    return;
  }
  FRESULT fr = f_mkdir(arg1);
  if (FR_OK != fr) printf("f_mkfs error: %s (%d)\n", FRESULT_str(fr), fr);
}

////////////////////////////////////////////////////////////////////////////////
//
// Scans the directory and works out the next file number to use
//
// Leaves max_filenum with that value
//
////////////////////////////////////////////////////////////////////////////////

void find_next_file_number(void)
{
  int file_n = 0;
  num_listfiles = 0;
  int i;
  
  char cwdbuf[FF_LFN_BUF] = {0};
  FRESULT fr;
  char const *p_dir;

  //DEBUG_STOP;

  if( cd_to_pak_dir(&oled0) )
    {
      return;
    }
  
  fr = f_getcwd(cwdbuf, sizeof cwdbuf);

  // printf will print to console
  if (FR_OK != fr)
    {
      printf("f_getcwd error: %s (%d)\n", FRESULT_str(fr), fr);
      return;
    }
  
  p_dir = cwdbuf;

  printf("File num search: %s\n", p_dir);
  
  DIR dj;      /* Directory object */
  FILINFO fno; /* File information */

  memset(&dj, 0, sizeof dj);
  memset(&fno, 0, sizeof fno);

  max_filenum = 0;
  
  fr = f_findfirst(&dj, &fno, p_dir, PAK_FILE_NAME_GLOB);

  if (FR_OK != fr)
    {
      printf("f_findfirst error: %s (%d)\n", FRESULT_str(fr), fr);
      return;
    }
  
  while( (fr == FR_OK) && fno.fname[0])
    { 
      if (fno.fattrib & AM_DIR)
	{
	  // Directory, we ignore these
	}
      else
	{
	  int filenum;
	  sscanf(fno.fname, "pak%d.opk", &filenum);

	  if( filenum > max_filenum )
	    {
	      max_filenum = filenum;
	    }
	}
       
      fr = f_findnext(&dj, &fno); /* Search for next item */
    }
  f_closedir(&dj);


}

// Mount the SD card.
// These could be menu options for plug/unplug of cards
// Sets sd_ok flag for later use
FATFS p_fs;

void mount_sd(void)
{
  //  p_fs = get_fs_by_name("0:");

  sd_ok_flag = false;

#if 0
  if (!p_fs)
    {
      oled_error("Mount:Unknown drive:'0:'");
      return;
    }
#endif
  
  FRESULT fr = f_mount(&p_fs, "0:", 1);
  
  if (FR_OK != fr)
    {
      oled_error("Mount error");
      return;
    }

  sd_ok_flag = true;
}

void unmount_sd(void)
{
  f_unmount("0:");
}

////////////////////////////////////////////////////////////////////////////////
//
// Puts up a list of the files on the SD card PAK directory, so one can be
// chosen.
//
// Only displays .opk files as they are the only ones that can be loaded.
//
////////////////////////////////////////////////////////////////////////////////


// returns the number of elements in a menu
int menu_size(struct MENU_ELEMENT *menu)
{
  int result = 0;
  
  while( menu->type != MENU_END )
    {
      result++;
      menu++;
    }
    
  return(result);
}

void button_list(struct MENU_ELEMENT *e)
{
  int file_n = 0;
  num_listfiles = 0;
  int i;
  
  char cwdbuf[FF_LFN_BUF] = {0};
  FRESULT fr;
  char const *p_dir;

  //DEBUG_STOP;

  mount_sd();
  
  if( cd_to_pak_dir(&oled0) )
    {
      unmount_sd();
      return;
    }

  f_chdrive("0:");
  fr = f_getcwd(cwdbuf, sizeof cwdbuf);

  if (FR_OK != fr)
    {
      printf("f_getcwd error: %s (%d)\n", FRESULT_str(fr), fr);
      unmount_sd();
      return;    f_chdrive("0:");
    }
  
  p_dir = cwdbuf;

  printf("\nDirectory Listing: %s\n", p_dir);
  
  DIR dj;      /* Directory object */
  FILINFO fno; /* File information */

  memset(&dj, 0, sizeof dj);
  memset(&fno, 0, sizeof fno);

  fr = f_findfirst(&dj, &fno, p_dir, "*");

  if (FR_OK != fr)
    {
      printf("f_findfirst error: %s (%d)\n", FRESULT_str(fr), fr);
      unmount_sd();
      return;
    }
  
  while( (fr == FR_OK) && fno.fname[0] && (num_listfiles < MAX_LISTFILES) )
    { 
      if (fno.fattrib & AM_DIR)
	{
	  // Directory, we gnore these
	}
      else
	{
	  char extension[40];
	  char name[80];
	   
	  // If the file has an extension of .opk then display it
	  // otherwise ignore.
	  extension[0] = '\0';

	  printf("\n%s", fno.fname);
	  
	  if( sscanf(fno.fname, "%[^.].%s", name, extension) )
	    {
	      if( strcmp(extension, "opk") == 0 )
		{
		  // Create a new menu element
		  // we also don't want to display anything before the offset
		  if( file_n >= file_offset )
		    {
		      // It is an opk file so display it
		      strncpy(&(names[num_listfiles][0]), fno.fname, MAX_NAME);
		       
		      //	display.println(&(names[nu);
		      listfiles[num_listfiles].text = &(names[num_listfiles][0]);
		      listfiles[num_listfiles].type = BUTTON_ELEMENT;
		      listfiles[num_listfiles].submenu = NULL;
		      listfiles[num_listfiles].function = button_select_file;
		       
		      num_listfiles++;
		    }
		  
		  // Next file
		  file_n++;
		}
	    }
	}
       
      fr = f_findnext(&dj, &fno); /* Search for next item */
    }
  f_closedir(&dj);

  printf("\n");
  
  // terminate the menu
  listfiles[num_listfiles].text = "";
  listfiles[num_listfiles].type = MENU_END;
  listfiles[num_listfiles].submenu = NULL;
  listfiles[num_listfiles].function = button_select_file;


#if 1// We know how big the menu is now
  if( num_listfiles != 0 )
    {
      file_menu_size = num_listfiles;
    }
#endif

  // Button actions modified
  buttons[0].event_fn = but_ev_up;
  buttons[1].event_fn = but_ev_down;
  buttons[2].event_fn = but_ev_file_select;

  // Set up menu of file names
  current_menu = &(listfiles[0]);
  draw_menu(&oled0, current_menu, false);

  unmount_sd();
}

#if 0
void run_ls()
{
  char *arg1 = strtok(NULL, " ");
  if (!arg1) arg1 = "";
  ls(arg1);
}
#endif

void run_cat()
{
  char *arg1 = strtok(NULL, " ");

  if (!arg1)
    {
      printf("Missing argument\n");
      return;
    }
  
  FIL fil;
  FRESULT fr = f_open(&fil, arg1, FA_READ);

  if (FR_OK != fr)
    {
      printf("f_open error: %s (%d)\n", FRESULT_str(fr), fr);
      return;
    }

  char buf[256];

  while (f_gets(buf, sizeof buf, &fil))
    {
      printf("%s", buf);
    }
  
  fr = f_close(&fil);

  if (FR_OK != fr)
    {
      printf("f_open error: %s (%d)\n", FRESULT_str(fr), fr);
    }
}


void run_big_file_test()
{
  
  const char *pcPathName = strtok(NULL, " ");
  
  if (!pcPathName)
    {
      printf("Missing argument\n");
      return;
    }
  
  const char *pcSize = strtok(NULL, " ");

  if (!pcSize)
    {
      printf("Missing argument\n");
      return;
    }

  size_t size = strtoul(pcSize, 0, 0);

  const char *pcSeed = strtok(NULL, " ");

  if (!pcSeed)
    {
      printf("Missing argument\n");
      return;
    }
  
  uint32_t seed = atoi(pcSeed);
  //big_file_test(pcPathName, size, seed);
}

void del_node(const char *path)
{
  FILINFO fno;
  char buff[256];
  /* Directory to be deleted */
  strlcpy(buff, path, sizeof(buff));
  /* Delete the directory */
  FRESULT fr = delete_node(buff, sizeof buff / sizeof buff[0], &fno);
  /* Check the result */
  if (fr)
    {
      printf("Failed to delete the directory %s. ", path);
      printf("%s error: %s (%d)\n", __func__, FRESULT_str(fr), fr);
    }
}

void run_del_node()
{
  char *arg1 = strtok(NULL, " ");
  if (!arg1)
    {
      printf("Missing argument\n");
      return;
    }
  del_node(arg1);
}

void run_cdef()
{
  f_mkdir("/cdef");  // fake mountpoint
  //vCreateAndVerifyExampleFiles("/cdef");
}

void run_swcwdt()
{
  /*vStdioWithCWDTest("/cdef");*/
}

void run_loop_swcwdt()
{
  int cRxedChar = 0;

  do
    {
      del_node("/cdef");
      run_cdef();
      run_swcwdt();
      cRxedChar = getchar_timeout_us(0);
    } while (PICO_ERROR_TIMEOUT == cRxedChar);
}

void run_start_logger()
{
  logger_enabled = true;
  next_time = delayed_by_ms(get_absolute_time(), period);
}

void run_stop_logger()
{
  logger_enabled = false;
}

void run_help();

typedef void (*p_fn_t)();
typedef struct {
  char const *const command;
  p_fn_t const function;
  char const *const help;
} cmd_def_t;

const cmd_def_t cmds[] = {
			  {"setrtc", run_setrtc,
			   "setrtc <DD> <MM> <YY> <hh> <mm> <ss>:\n"
			   "  Set Real Time Clock\n"
			   "  Parameters: new date (DD MM YY) new time in 24-hour format "
			   "(hh mm ss)\n"
			   "\te.g.:setrtc 16 3 21 0 4 0"},
			  {"date", run_date, "date:\n Print current date and time"},
			  {"lliot", run_lliot,
			   "lliot <drive#>:\n !DESTRUCTIVE! Low Level I/O Driver Test\n"
			   "\te.g.: lliot 1"},
			  {"format", run_format,
			   "format [<drive#:>]:\n"
			   "  Creates an FAT/exFAT volume on the logical drive.\n"
			   "\te.g.: format 0:"},
			  {"mount", run_mount,
			   "mount [<drive#:>]:\n"
			   "  Register the work area of the volume\n"
			   "\te.g.: mount 0:"},
			  {"unmount", run_unmount,
			   "unmount <drive#:>:\n"
			   "  Unregister the work area of the volume"},
			  {"chdrive", run_chdrive,
			   "chdrive <drive#:>:\n"
			   "  Changes the current directory of the logical drive.\n"
			   "  <path> Specifies the directory to be set as current directory.\n"
			   "\te.g.: chdrive 1:"},
			  {"getfree", run_getfree,
			   "getfree [<drive#:>]:\n"
			   "  Print the free space on drive"},
			  {"cd", run_cd,
			   "cd <path>:\n"
			   "  Changes the current directory of the logical drive.\n"
			   "  <path> Specifies the directory to be set as current directory.\n"
			   "\te.g.: cd /dir1"},
			  {"mkdir", run_mkdir,
			   "mkdir <path>:\n"
			   "  Make a new directory.\n"
			   "  <path> Specifies the name of the directory to be created.\n"
			   "\te.g.: mkdir /dir1"},
			  {"del_node", run_del_node,
			   "del_node <path>:\n"
			   "  Remove directory and all of its contents.\n"
			   "  <path> Specifies the name of the directory to be deleted.\n"
			   "\te.g.: del_node /dir1"},
#if 0
			  {"ls", run_ls, "ls:\n  List directory"},
#endif			  
			  {"cat", run_cat, "cat <filename>:\n  Type file contents"},
			  //    {"simple", simple, "simple:\n  Run simple FS tests"},
			  {"big_file_test", run_big_file_test,
			   "big_file_test <pathname> <size in bytes> <seed>:\n"
			   " Writes random data to file <pathname>.\n"
			   " <size in bytes> must be multiple of 512.\n"
			   "\te.g.: big_file_test bf 1048576 1\n"
			   "\tor: big_file_test big3G-3 0xC0000000 3"},
			  {"cdef", run_cdef,
			   "cdef:\n  Create Disk and Example Files\n"
			   "  Expects card to be already formatted and mounted"},
			  {"swcwdt", run_swcwdt,
			   "\nswcwdt:\n Stdio With CWD Test\n"
			   "Expects card to be already formatted and mounted.\n"
			   "Note: run cdef first!"},
			  {"loop_swcwdt", run_loop_swcwdt,
			   "\nloop_swcwdt:\n Run Create Disk and Example Files and Stdio With CWD "
			   "Test in a loop.\n"
			   "Expects card to be already formatted and mounted.\n"
			   "Note: Type any key to quit."},
			  {"start_logger", run_start_logger,
			   "start_logger:\n"
			   "  Start Data Log Demo"},
			  {"stop_logger", run_stop_logger,
			   "stop_logger:\n"
			   "  Stop Data Log Demo"},
			  {"help", run_help,
			   "help:\n"
			   "  Shows this command help."}};
void run_help() {
  for (size_t i = 0; i < count_of(cmds); ++i) {
    printf("%s\n\n", cmds[i].help);
  }
}

void process_stdio(int cRxedChar)
{
  char cmd[256];
  size_t ix;
  
  if(  !isprint(cRxedChar) &&
       !isspace(cRxedChar) &&
       '\r' != cRxedChar   &&
       '\b' != cRxedChar    &&
       cRxedChar != (char)127)
    {
    return;
    }
  
  printf("%c", cRxedChar);  // echo
  stdio_flush();

  if (cRxedChar == '\r')
    {
      /* Just to space the output from the input. */
      printf("%c", '\n');
      stdio_flush();
      
      if (!strnlen(cmd, sizeof cmd))
	{  // Empty input
	  printf("> ");
	  stdio_flush();
	  return;
	}
      
      /* Process the input string received prior to the newline. */
      char *cmdn = strtok(cmd, " ");
      
      if (cmdn)
	{
	  size_t i;
	  for (i = 0; i < count_of(cmds); ++i)
	    {
	      if (0 == strcmp(cmds[i].command, cmdn))
		{
		  (*cmds[i].function)();
		  break;
		}
	    }
	  if (count_of(cmds) == i)
	    {
	      printf("Command \"%s\" not found\n", cmdn);
	    }
	}
      
      ix = 0;
      memset(cmd, 0, sizeof cmd);
      printf("\n> ");
      stdio_flush();
    }
  else
    {  // Not newline
      if (cRxedChar == '\b' || cRxedChar == (char)127)
	{
	  /* Backspace was pressed.  Erase the last character
	     in the string - if any. */
	  if (ix > 0)
	    {
	      ix--;
	      cmd[ix] = '\0';
	    }
	}
      else
	{
	  /* A character was entered.  Add it to the string
	     entered so far.  When a \n is entered the complete
	     string will be passed to the command interpreter. */
	  if (ix < sizeof cmd - 1)
	    {
	      cmd[ix] = cRxedChar;
	      ix++;
	    }
	}
    }
}

////////////////////////////////////////////////////////////////////////////////
// Menu system
//
typedef void (*FPTR)();
typedef void (*CMD_FPTR)(char *cmd);


// Debounce
#define MAX_BUT_COUNT 6

struct MENU_ELEMENT listfiles[MAX_LISTFILES+1];
int num_listfiles;
char names[MAX_LISTFILES][MAX_NAME];
char current_file[MAX_NAME+1];

int cd_to_pak_dir(I2C_SLAVE_DESC *slave)
{
  char line[40];
  FRESULT fr;
  char cwdbuf[FF_LFN_BUF] = {0};
  char const *p_dir;

  //DEBUG_STOP

  f_chdrive("0:");

#if 0
  // Are we in the pak directory already?
  fr = f_getcwd(cwdbuf, sizeof cwdbuf);
  if (FR_OK != fr)
    {
      oled_clear_display(slave);
      oled_set_xy(slave, 0, 0);
      sprintf(line, "cwd error");
      oled_display_string(slave, line);

      oled_set_xy(slave, 0, 8);
      sprintf(line, "cwd:'%s'", cwdbuf);
      oled_display_string(slave, line);
      
      return;
    }

  if( strcmp(cwdbuf, PAK_DIR) != 0 )
    {
#endif
      
      // Change to the PAK directory
      fr = f_chdir(PAK_DIR);
      if (FR_OK != fr)
	{
	  oled_clear_display(slave);
	  oled_set_xy(slave, 0, 0);
	  sprintf(line, "Error opening");
	  oled_display_string(slave, line);
	  
	  oled_set_xy(slave, 0, 8);
	  sprintf(line, "directory");
	  oled_display_string(slave, line);
	  
	  oled_set_xy(slave, 0, 16);
	  sprintf(line, PAK_DIR);
	  oled_display_string(slave, line);
	  loop_delay(3000000);      
	  return(1);
	}
#if 0      
    }
#endif
  return(0);
}

////////////////////////////////////////////////////////////////////////////////
//
// Read and process the config file
//
////////////////////////////////////////////////////////////////////////////////

void process_config_file(I2C_SLAVE_DESC *slave)
{
  char line[40];
  char fileline[80];

  //DEBUG_STOP;
  
  mount_sd();
  
  if( cd_to_pak_dir(slave) )
    {
      unmount_sd();
      return;
    }  mount_sd();
  
  if( cd_to_pak_dir(slave) )
    {
      unmount_sd();
      return;
    }

  
  oled_clear_display(slave);
  oled_set_xy(slave, 0, 0);
  sprintf(line, "Processing");
  oled_display_string(slave, line);
      
  oled_set_xy(slave, 0, 8);
  sprintf(line, "config.txt");
  oled_display_string(slave, line);
  
  loop_delay(1000000);

  // Read the file from the SD card into the pak memory
  FF_FILE *fp = ff_fopen("config.txt", "r");

  if (fp == NULL)
    {
      sprintf(line, "Failed to open:");
      oled_clear_display(slave);
      oled_set_xy(slave, 0, 0);
      oled_display_string(slave, line);
      
      oled_set_xy(slave, 0, 7);
      sprintf(line, "config.txt");
      oled_display_string(slave, line);

      loop_delay(3000000);
      unmount_sd();
      return;
    }



  
  // Get lines from the file
  while( ff_fgets(&(fileline[0]), sizeof(fileline)-1, fp) != NULL )
    {
      char keyword[80];
      char name[80];

      // Remove trailing newline
      fileline[strlen(fileline)-1] = '\0';
      
      keyword[0] = '\0';
      name[0] = '\0';

      oled_clear_display(slave);
      oled_set_xy(slave, 0, 0);
      sprintf(line, "[%s]", fileline);
      oled_display_string(slave, line);
      loop_delay(3000000);
      
      sscanf(fileline, "%[^=]=%s", keyword, name);

      if( strcmp(keyword, "startfile") == 0 )
	{
	  strcpy(current_file, name);
	  
	  // read the file
	  core_read(&oled0, current_file);
	}
      
      if( strcmp(keyword, "brightness") == 0 )
	{
	  sscanf(name, "%d", &brightness_percent);
	  oled_set_brightness(&oled0, brightness_percent);
	  
	  oled_clear_display(slave);
	  oled_set_xy(slave, 0, 0);
	  sprintf(line, "Brightness: %d%%", brightness_percent);
	  oled_display_string(slave, line);
	  loop_delay(3000000);
	}
      
    }
  
  ff_fclose(fp);
  unmount_sd();
}

// Read the file with the given name into the buffer
// Pak images are in a directory called PAK

void core_read(I2C_SLAVE_DESC *slave, char * arg)
{
  char line[40];

  //DEBUG_STOP;

  mount_sd();
  
  if( cd_to_pak_dir(slave) )
    {
      unmount_sd();
      return;
    }
  
  oled_clear_display(slave);
  oled_set_xy(slave, 0, 0);
  sprintf(line, "Reading file");
  oled_display_string(slave, line);
      
  oled_set_xy(slave, 0, 8);
  sprintf(line, "%s", arg);
  oled_display_string(slave, line);
  
  loop_delay(1000000);

  // Read the file from the SD card into the pak memory
  FIL fil;
  FRESULT fr = f_open(&fil, arg, FA_READ);

  if (FR_OK != fr)
    {
      sprintf(line, "Failed to open:");
      oled_clear_display(slave);
      oled_set_xy(slave, 0, 0);
      oled_display_string(slave, line);
      
      oled_set_xy(slave, 0, 7);
      sprintf(line, "%s", arg);
      oled_display_string(slave, line);

      loop_delay(3000000);
      unmount_sd();
      return;
    }
  
  char buf[1];
  int pak_i = 0;
  int br = 0;
  bool done = false;
  char name[80];
  char extension[20];
  bool modify_header = false;
  
  // If the extension is .opk then we drop the first 6 bytes
  if( sscanf(arg, "%[^.].%s", name, extension) == 2 )
    {
      if( strcmp(extension, "opk") == 0 )
	{
	  // Drop 6 bytes from start of file
	  for(int i=0; i<6; i++)
	    {
	      f_read(&fil, buf, sizeof buf, &br);
	    }

	  // We need to modify the header, so set flag telling us to do
	  // that later
	  modify_header = true;
	}
    }
  
  while( !done )
    {
      f_read(&fil, buf, sizeof buf, &br);
      
      if( br == 0 )
	{
	  done = true;
	  continue;
	}
      
      for(int i=0; i<br; i++)
	{
	  pak_memory[pak_i++] = buf[i];
	}
    }
  f_close(&fil);
  
  oled_set_xy(slave, 0, 16);
  sprintf(line, "%d bytes read", pak_i);
  oled_display_string(slave, line);

  // Do we modify the header?

  if( modify_header )
    {
      uint16_t csum = 0;
      
      // For reference, this arrangement works as 32K pack
      //  pak_memory[0] = 0x78;
      //  pak_memory[1] = 0x04; //32K, could allow original length through
      //  pak_memory[2] = 0x56;
      //  pak_memory[3] = 0x00;
      //  pak_memory[4] = 0x03;
      //  pak_memory[5] = 0x02;
      //  pak_memory[6] = 0x35;
      //  pak_memory[7] = 0x46;
      //  pak_memory[8] = 0x06;
      //  pak_memory[9] = 0x4c;

      // Pass flags through as we can now handle paged packs
#if 0
      pak_memory[0] = 0x68;
#endif

      // We can allow sizes up to and including 128K
      if( pak_memory[1] > 0x10 )
	{
	  pak_memory[1] = 0x10; //128K
	}
      
      // Pass next bytes on unaltered
#if 0      
      pak_memory[2] = 0x56;
      pak_memory[3] = 0x00;
      pak_memory[4] = 0x03;
      pak_memory[5] = 0x02;
      pak_memory[6] = 0x35;
      pak_memory[7] = 0x46;
#endif
      
      // Calculate correct checksum
      // The next two bytes are a cheksum of the first four WORDS
      for(int i = 0; i<8; i+=2)
	{
	  csum += pak_memory[i]*256+pak_memory[i+1];
	}
      pak_memory[8] = csum >> 8;
      pak_memory[9] = csum & 0xFF;
      
    }
  
  loop_delay(3000000);
  unmount_sd();
}

// Writes the buffer to a file.
// Deletes any file that exists with the same name so that the resulting
// file is the same size as the buffer
// Searches the card directory for the highest file number and uses the next one
//

void core_writefile(bool oled_nserial)
{
  char filename[20];
  int i;
  FRESULT fr;
  FIL fp;
  int bytes_written = 0;
  char line[40];

  //DEBUG_STOP

  mount_sd();
  
  if( cd_to_pak_dir(&oled0) )
    {
      unmount_sd();
      return;
    }

  find_next_file_number();
  sprintf(filename, PAK_FILE_NAME_FORMAT, ++max_filenum);
  
  oled_clear_display(&oled0);
  oled_set_xy(&oled0, 0, 0);
  oled_display_string(&oled0, "Writing");
  oled_set_xy(&oled0, 0, 8);
  oled_display_string(&oled0, filename);
  
  // Open file for writing
  fr = f_open(&fp, filename, FA_CREATE_NEW | FA_WRITE);

  if (FR_OK != fr && FR_EXIST != fr)
    {
      oled_error("Open error");
      unmount_sd();
      return;
    }

  // As we are writing an OPK file, we add a header in the first 6 bytes. We don't
  BYTE hdr[6] = {'O', 'P', 'K', 0, 0, 0};

  f_write (&fp, &(hdr[0]), 6, &bytes_written);
  
  // Write the entire buffer in one go
  f_write (&fp, &(pak_memory[0]), PAK_MEMORY_SIZE, &bytes_written);

  bytes_written += 6;
  
  fr = f_close(&fp);
  if (FR_OK != fr)
    {
      printf("f_close error: %s (%d)\n", FRESULT_str(fr), fr);
      unmount_sd();
      return;
    }

  oled_set_xy(&oled0, 0, 3*8);
  sprintf(line, "%d bytes", bytes_written);
  oled_display_string(&oled0, line);

  unmount_sd();

}

// The switch menu/OLED display system
void to_back_menu(struct MENU_ELEMENT *e)
{
  menu_selection = 0;
  menu_offset = 0;
  current_menu = last_menu;
  draw_menu(&oled0, current_menu, true);
}

void to_home_menu(struct MENU_ELEMENT *e)
{
  menu_selection = 0;
  menu_offset = 0;
  current_menu = the_home_menu;
  draw_menu(&oled0, current_menu, true);
}

// Write an OPK file from SD card to the datapack
// Writes the previously selected file

void button_write_file(struct MENU_ELEMENT *e)
{
  write_opk_file(&oled0, current_file);

  loop_delay(3000000);
  draw_menu(&oled0, current_menu, true);
}

// Compare an OPK file from SD card to the datapack
// Compares the previously selected file

void button_compare_file(struct MENU_ELEMENT *e)
{
  compare_opk_file(&oled0, current_file);

  loop_delay(3000000);
  draw_menu(&oled0, current_menu, true);
}


// The button function puts up to the first 7 files on screen then set sup a button handler
// which will display subsequent pages.
// We use the menu structures to display the names and allow selection

// File selected
void button_select_file(struct MENU_ELEMENT *e)
{
}

//--------------------------------------------------------------------------------

// Move up in a menu

void but_ev_up()
{
  // Move up one place
  menu_selection--;

  // Keep within bounds
  if( menu_selection <= 0 )
    {
      menu_selection = 0;
    }

  // Now move offset up if it is greter than selection
  if( menu_offset > menu_selection )
    {
      menu_offset = menu_selection;
    }
  
  draw_menu(&oled0, current_menu, false);
}

void but_ev_down()
{
  // Move cursor down one entry
  menu_selection++;

  // Are we off the end of the menu?
  if( menu_selection == menu_size(current_menu) )
    {
      // At last element of menu
      menu_selection--;
    }

  // Do we need to pull the top element down?
  if( (menu_selection - menu_offset) >= MENU_MAX )
    {
      menu_offset = menu_selection - MENU_MAX+1;
      if( menu_offset < 0 )
	{
	  menu_offset = 0;
	}
    }
  
  draw_menu(&oled0, current_menu, false);
  //  button_list(NULL);
}

// Store file name and exit menu
// File can be read later

void but_ev_file_select()
{
  char line[40];
  
  strcpy(current_file, listfiles[menu_selection].text);
  file_offset = 0;

  oled_clear_display(&oled0);
  oled_set_xy(&oled0, 0,0);
  sprintf(line, "Selected File:");
  oled_display_string(&oled0, line);

  oled_set_xy(&oled0, 0,14);
  sprintf(line, "%s", current_file);
  oled_display_string(&oled0, line);

  loop_delay(3000000);

  // As well as selecting the file, read in in to the buffer as well
  core_read(&oled0, current_file);

  menu_selection = 0;
  to_home_menu(NULL);
  
  buttons[0].event_fn = but_ev_up;
  buttons[1].event_fn = but_ev_down;
  buttons[2].event_fn = but_ev_select;
}

void button_to_home(struct MENU_ELEMENT *e)
{
  to_home_menu(NULL);
}

// Get a list of the files on the SD card and display
// them so one can be selected.

void button_list_old(struct MENU_ELEMENT *e)
{
#if 0
  File dir;
  int file_n = 0;
  num_listfiles = 0;
  int i;

  dir = SD.open("/");

  // return to the first file in the directory
  dir.rewindDirectory();
  
  while (num_listfiles < MAX_LISTFILES) {

    File entry =  dir.openNextFile();

    if (! entry) {
      // no more files
      // terminate menu
      listfiles[num_listfiles].text = "";
      listfiles[num_listfiles].type = MENU_END;
      listfiles[num_listfiles].submenu = NULL;
      listfiles[num_listfiles].function = button_select_file;
      entry.close();
      break;
    }

    
    // We don't allow directories and don't ount them
    if (entry.isDirectory())
      {
      }
    else
      {
#if DEBUG	
	printf("BList-file_n:");
	printf(file_n);
	printf(entry.name());
	printf("  num_listfiles:");
	printf("%d\n", num_listfiles);
#endif
	// Create a new menu element
	// we also don't want to display anything before the offset
	if( file_n >= file_offset )
	  {
	    strncpy(&(names[num_listfiles][0]), entry.name(), MAX_NAME);
	    //	display.println(&(names[nu);
	    listfiles[num_listfiles].text = &(names[num_listfiles][0]);
	    listfiles[num_listfiles].type = BUTTON_ELEMENT;
	    listfiles[num_listfiles].submenu = NULL;
	    listfiles[num_listfiles].function = button_select_file;
	    
	    num_listfiles++;
	  }
	// Next file
	file_n++;

      }
    entry.close();
    
  }

  dir.close();

  // terminate menu
  listfiles[num_listfiles].text = "";
  listfiles[num_listfiles].type = MENU_END;
  listfiles[num_listfiles].submenu = NULL;
  listfiles[num_listfiles].function = button_select_file;

  // We know how big the menu is now
#if 0
  if( num_listfiles != 0 )
    {
      menu_size = num_listfiles;
    }
#endif
  
  // Button actions modified
  buttons[0].event_fn = but_ev_up;
  buttons[1].event_fn = but_ev_down;
  buttons[2].event_fn = but_ev_file_select;

  // Set up menu of file names
  current_menu = &(listfiles[0]);
  draw_menu(&oled0, current_menu, false);
#endif
}


#define COLUMNS 5
#define PAGE_LENGTH 30

// Display the buffer

int display_offset = 0;

void but_page_up()
{
  if( display_offset > PAGE_LENGTH )
    {
      display_offset -= PAGE_LENGTH;
    }
  else
    {
      display_offset = 0;
    }
  button_display(NULL);
}

void but_page_down()
{
#if 0
  display_offset += PAGE_LENGTH;
  
  if( display_offset >= bytecount )
    {
      display_offset = bytecount-PAGE_LENGTH;
    }

  if( display_offset < 0 )
    {
      display_offset = 0;
    }
  
  button_display(NULL);
#endif
}

void but_page_exit()
{
  display_offset = 0;
  draw_menu(&oled0,current_menu, true);

  buttons[0].event_fn = but_ev_up;
  buttons[1].event_fn = but_ev_down;
  buttons[2].event_fn = but_ev_select;

}

void button_display(struct MENU_ELEMENT *e)
{
#if 0
  int i;
  char ascii[17];
  char c[5];
  
  int ascii_i = 0;

  oled_clear_display(&oled0);
  
  //display.clearDisplay();
  
  for(i=0; (i<bytecount) && (i<PAGE_LENGTH); i++)
    {
      if( isprint(stored_bytes[i]) )
	{
	  sprintf(ascii, "%c", stored_bytes[i+display_offset]);
	}
      else
	{
	  sprintf(ascii, ".");
	}
      
      sprintf(c,     "%02X",  stored_bytes[i+display_offset]);

#if 0
      display.setCursor(6*15+(i%COLUMNS)*1*6, 8*(i/COLUMNS+1));
      display.println(ascii);
      display.setCursor(10*0+(i%COLUMNS)*2*8, 8*(i/COLUMNS+1));
      display.print(c);
#endif
    }

  // Drop into page up and down and exit buttoin handlers
  buttons[0].event_fn = but_page_up;
  buttons[1].event_fn = but_page_down;
  buttons[2].event_fn = but_page_exit;

  //display.display();
#endif
}


void button_exit(struct MENU_ELEMENT *e)
{
  menuloop_done = 1;
}

void button_send(struct MENU_ELEMENT *e)
{
  //send_databytes(true);
  draw_menu(&oled0, current_menu, true);
}

void button_auto_size(struct MENU_ELEMENT *e)
{
  auto_size(true);
  draw_menu(&oled0, current_menu, true);
}


////////////////////////////////////////////////////////////////////////////////
//
//
// Read the datapack and write the contents to SD card
//
//
////////////////////////////////////////////////////////////////////////////////

void button_read(struct MENU_ELEMENT *e)
{
  // Find a filename that hasn't been used
  char filename[20];
  int file_index = 0;
  
  mount_sd();
  
  if( cd_to_pak_dir(&oled0) )
    {
      unmount_sd();
      return;
    }

  for(;;)
    {
      sprintf(filename, "PAK%04d.OPK", file_index);
      
      FF_FILE *fp = ff_fopen(filename, "r");
      
      if (fp == NULL)
	{
	  // We have a filename we can use
	  break;
	}
      else
	{
	  // Try the next index number
	  file_index++;
	  ff_fclose(fp);

	}
    }

  unmount_sd();
  
  // We have a filename now, use it
  read_opk_file(&oled0, filename);
  
  draw_menu(&oled0, current_menu, true);
}



////////////////////////////////////////////////////////////////////////////////
//
// Auto size a datapack
//
////////////////////////////////////////////////////////////////////////////////

// This will not work with a blank datapack.

uint8_t page0[256];
int paged_size = 0;
int linear_size = 0;
uint32_t i;

int check_for_page0(void)
{

  uint8_t byte;
  
  ArdDataPinsToInput();          // ensure Arduino data pins are set to input
  packOutputAndSelect();         // Enable pack data bus output then select it
  resetAddrCounter();            // reset counters

  // Skip page 0
  for(int x=0; x<256; x++)
    {
      nextAddress();
    }
  
  // Go to every page over the possible address range
  for(int i=256; i<128*1024-256; i+=256)
    {
      // See if page0 is here
      boolean matched = true;
      
      for(int j=0; j<256; j++)
	{
	  byte = readByte();
	  
	  //printf("\n Checking %02X against %02X at %06X", page0[j], byte, i);		 

	  if( page0[j] == byte )
	    {
	      // Match
	    }
	  else
	    {
	      // No match
	      matched = false;
	    }
	  nextAddress();
	}

      if( matched )
	{
	  // Page 0 has appeared here, so assume address range has wrapped
	  // return start of matchinmg wrapped page
	  packDeselectAndInput();
	  return(i);
	}
    }

  packDeselectAndInput();
  return(i);

}

////////////////////////////////////////////////////////////////////////////////
//
// Auto size
//
////////////////////////////////////////////////////////////////////////////////


void auto_size(int oled_nserial)
{
  // Take whatever datapack is attached and attempt to work out
  // the size and addressing mode

  // Check the first 256 bytes against other 256 byte pages. When we get a math,
  // assume that is the same page and addressing has wrapped.

  // Read the first page
  ArdDataPinsToInput();          // ensure Arduino data pins are set to input
  packOutputAndSelect();         // Enable pack data bus output then select it
  resetAddrCounter();            // reset counters

  if( oled_nserial )
    {
      oled_clear_display(&oled0);
      oled_set_xy(&oled0, 0, 0);
      oled_printf(&oled0, "Auto Sizing Datapack");
    }
  
  printf("\nAuto sizing datapack\n");
  
  printf("\nReading page 0");
  
  for(int i=0; i<256; i++)
    {
      if( (i%16)==0 )
	{
	  printf("\n%02X: ", i);
	}
      
      page0[i] = readByte();
      printf("%02X ", page0[i]);
      
      nextAddress();
    }

  packDeselectAndInput();

  // We have a page0 that we can check for throughout the
  // pack address range...
  
  // First, addressing mode
  paged_addr = false;
  linear_size = check_for_page0();
  paged_addr = true;
  paged_size = check_for_page0();


  printf("\nPaged  addressing wrap:0x%06X (Size %d)", paged_size, paged_size);
  printf("\nLinear addressing wrap:0x%06X (Size %d)", linear_size, linear_size);
  int datapack_length;
  if( paged_size > linear_size )
    {
      datapack_length = paged_size;
      printf("\nPage addressed datapack");
      paged_addr = true;
    }
  else
    {
      datapack_length = linear_size;
      printf("\nLinear addressed datapack");
      paged_addr = false;
    }
  printf("\n");

  if( oled_nserial )
    {
      oled_set_xy(&oled0, 0, 8);
      oled_printf(&oled0, "%d bytes", datapack_length);
      oled_set_xy(&oled0, 0, 16);
      oled_printf(&oled0, "%s", paged_addr?"Page":"Linear");
      oled_set_xy(&oled0, 0, 24);
      oled_printf(&oled0, " addressed pack");
      loop_delay(5000000);
    }
}


////////////////////////////////////////////////////////////////////////////////
//
// Drives Vpp with square wave to test the switch circuit
//
////////////////////////////////////////////////////////////////////////////////

void button_cycle_vpp(struct MENU_ELEMENT *e)
{

  for(;;)
    {
      gpio_put(VPP_ON_PIN, 0);
      //sleep_ms(500);
      loop_delay(100000);
      
      gpio_put(VPP_ON_PIN, 1);
      //      sleep_ms(500);
      loop_delay(100000);
    }
}


const struct MENU_ELEMENT test_menu[] =
  {
   {BUTTON_ELEMENT, "Cycle Vpp",                  NULL,     button_cycle_vpp},
   {BUTTON_ELEMENT, "Exit",                       NULL,     to_home_menu},
   {MENU_END,       "",                           NULL,     NULL},
  };

const struct MENU_ELEMENT info_menu[] =
  {
   {BUTTON_ELEMENT, "Pack ID",                    NULL,     button_pak_id},
   {BUTTON_ELEMENT, "Pack Header",                NULL,     button_pak_hdr},
   {BUTTON_ELEMENT, "Blank Check",                NULL,     button_blank},
   {BUTTON_ELEMENT, "Auto Size",                  NULL,     button_auto_size},
   {BUTTON_ELEMENT, "Exit",                       NULL,     to_home_menu},
   {MENU_END,       "",                           NULL,     NULL},
  };


const struct MENU_ELEMENT home_menu[] =
  {
   {BUTTON_ELEMENT, "List",                       NULL,     button_list},
   {BUTTON_ELEMENT, "Write File to Pak",          NULL,     button_write_file},
   {BUTTON_ELEMENT, "Compare File",               NULL,     button_compare_file},
   {BUTTON_ELEMENT, "Display",                    NULL,     button_display},
   {SUB_MENU,       "Test",                       test_menu,     NULL},
   {SUB_MENU,       "Info",                       info_menu,     NULL},
   {BUTTON_ELEMENT, "Read Pak to File",           NULL,     button_read},
   {BUTTON_ELEMENT, "Exit",                       NULL,     button_exit},
   {MENU_END,       "",                           NULL,     NULL},
  };

// Clear flag indicates whether we redraw the menu text and clear the screen. Or not.
//
// Menus are displayed starting at menu_offset and will only put
// MENU_MAX lines on the screen
// This allows eithee size of display to be used

void draw_menu(I2C_SLAVE_DESC *slave, struct MENU_ELEMENT *e, bool clear)
{
  int i = 0;
  char etext[50];

  e = current_menu;

  //DEBUG_STOP
  
  // Clear screen
  if(clear,1)
    {
      oled_clear_display(slave);
      //display.clearDisplay();
    }

  int entry_number = -1;
  
  while( e->type != MENU_END )
    {
      entry_number++;
      
      // Skip the first menu_offset entries
      if( entry_number < menu_offset )
	{
	  e++;
	  continue;
	}

      // Don't ever display more than MENU_MAX elements
      if( (entry_number - menu_offset) > MENU_MAX )
	{
	  break;
	}

      if( entry_number == menu_selection )
	{
	  sprintf(etext, ">%-19s", e->text);
	}
      else
	{
	  sprintf(etext, " %-19s", e->text);
	}
      
      switch(e->type)
	{
	case BUTTON_ELEMENT:
	  oled_set_xy(slave, 0, i*8);
	  //display.printChar(curs);
	  if( clear,1 )
	    {
	      oled_display_string(slave, etext);
	    }
	  break;

	case SUB_MENU:
	  oled_set_xy(slave, 0, i*8);
	  oled_display_string(slave, etext);
	  break;
	}

      e++;
      i++;
    }
  
  //menu_size = i;

  // Blank the other entries
  //make sure menu_selection isn't outside the menu
  if( menu_selection >= menu_size(current_menu) )
    {
      menu_selection = menu_size(current_menu)-1;
    }

  for(; i<MENU_MAX; i++)
    {
      oled_set_xy(slave, 0, i*8);
      oled_display_string(slave, "               ");
      //      display.setCursor(0, i*8);
      //display.println("               ");
    }

#if 0  
  for(i=menu_offset; i<menu_offset+MENU_MAX-1;i++)
    {
      if( i == menu_selection )
	{
	  curs = ">";	  
	}
      else
	{
	  curs = " ";
	}

      oled_set_xy(slave, 0, i*8);
      oled_display_string(slave, curs);

      //display.setCursor(0, i*8);
      //display.print(curs);
    }
#endif  
#if 0
  char line[40];
  oled_set_xy(slave, 0, 8);
  sprintf(line, "%d %d %d %d  ", menu_selection, menu_offset, menu_size(current_menu), file_menu_size);
  oled_display_string(slave, line);
#endif
}

void old_draw_menu(I2C_SLAVE_DESC *slave, struct MENU_ELEMENT *e, bool clear)
{
  int i = 0;
  char *curs = " ";
  char etext[20];

  //DEBUG_STOP
  
  // Clear screen
  if(clear,1)
    {
      oled_clear_display(slave);
      //display.clearDisplay();
    }
  
  while( e->type != MENU_END )
    {
      sprintf(etext, " %-19s", e->text);
      
      switch(e->type)
	{
	case BUTTON_ELEMENT:
	  oled_set_xy(slave, 0, i*8);
	  //display.printChar(curs);
	  if( clear,1 )
	    {
	      oled_display_string(slave, etext);
	    }
	  break;

	case SUB_MENU:
	  oled_set_xy(slave, 0, i*8);
	  //	  display.setCursor(0, i*8);
	  //display.printChar(curs);
	  if ( clear,1 )
	    {
	      oled_display_string(slave, etext);
	      //	      display.println(etext);
	    }
	  break;
	}
      e++;
      i++;
    }
  
  //menu_size = i;

  // Blank the other entries
  //make sure menu_selection isn't outside the menu
  if( menu_selection >= menu_size(current_menu) )
    {
      menu_selection = menu_size(current_menu)-1;
    }

  for(; i<MAX_LISTFILES; i++)
    {
      oled_set_xy(slave, 0, i*8);
      oled_display_string(slave, "               ");
      //      display.setCursor(0, i*8);
      //display.println("               ");
    }

  for(i=0;i<menu_size(current_menu);i++)
    {
      if( i == menu_selection )
	{
	  curs = ">";	  
	}
      else
	{
	  curs = " ";
	}

      oled_set_xy(slave, 0, i*8);
      oled_display_string(slave, curs);

      //display.setCursor(0, i*8);
      //display.print(curs);
    }
}

// Null button event function
void but_ev_null()
{ 
}

void old_but_ev_up()
{
  if( menu_selection == 0 )
    {
      menu_selection = menu_size(current_menu) - 1;
    }
  else
    {
      menu_selection = (menu_selection - 1) % menu_size(current_menu);
    }
  
  draw_menu(&oled0, current_menu, false);
}

void old_but_ev_down()
{

  //DEBUG_STOP

  menu_selection = (menu_selection + 1) % menu_size(current_menu);

  draw_menu(&oled0, current_menu, false);
}

void but_ev_select()
{
  struct MENU_ELEMENT *e;
  int i = 0;
  
  // Do what the current selection says to do
  for(e=current_menu, i=0; (e->type != MENU_END); i++, e++)
    {
      if( i == menu_selection )
	{
	  switch(e->type)
	    {
	    case SUB_MENU:
	      current_menu = (struct MENU_ELEMENT *)e->submenu;
	      menu_offset = 0;
	      menu_selection = 0;
	      
	      draw_menu(&oled0, current_menu, true);
	      break;
	      
	    default:
	      // Do action
	      (e->function)(e);
	      break;
	    }
	}
    }
}


void init_buttons()
{
  for(int i=0; i<NUM_BUTTONS; i++)
    {
      buttons[i].count = 0;
      buttons[i].pressed = false;
      buttons[i].last_pressed = false;
      buttons[i].event_fn = but_ev_null;
    }

  buttons[0].event_fn = but_ev_up;
  buttons[1].event_fn = but_ev_down;
  buttons[2].event_fn = but_ev_select;
}

void update_buttons()
{
  for(int i=0; i<NUM_BUTTONS; i++)
    {
      if( gpio_get(but_pins[i]) == 0 )
	{
	  if( buttons[i].count < MAX_BUT_COUNT )
	    {
	      buttons[i].count++;
	      if( buttons[i].count == MAX_BUT_COUNT )
		{
		  // Just got to MAX_COUNT
		  buttons[i].pressed = true;
		}
	    }
	}
      else
	{
	  if( buttons[i].count > 0 )
	    {
	      buttons[i].count--;
	      
	      if( buttons[i].count == 0 )
		{
		  // Just got to zero
		  buttons[i].pressed = false;
		}
	    }
	}
      
      // If button has gone from pressed to not pressed then we treat that as a key event
      if( (buttons[i].last_pressed == true) && (buttons[i].pressed == false) )
	{
	  (buttons[i].event_fn)();
	}

      buttons[i].last_pressed = buttons[i].pressed;
    }
}

////////////////////////////////////////////////////////////////////////////////

// Ported code from Martin Prest's datapack reader/writer
//
// https://github.com/martinprest/Psion2-Datapak-Rampak-reader-writer
//
// (git@github.com:martinprest/Psion2-Datapak-Rampak-reader-writer.git)
//
//------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------

void delayShort()
{
  // 1 us delay
  loop_delay(10);
}

//------------------------------------------------------------------------------------------------------

void delayLong()
{ // 3 us delay
  loop_delay(30);
}

// Switch data lines to inputs
// Also swap level shifters to match

void ArdDataPinsToInput(void)
{
  int i;

  gpio_put(LS_DIR_PIN, 0);
  
  for(i=0; i<8; i++)
    {
      if (datapak_mode)
	{
	  // Pull ups
	  gpio_set_pulls(data_pin[i], 1, 0);
	}
      else
	{
	  // No pull ups
	  gpio_set_pulls(data_pin[i], 0, 0);
	}
      
      gpio_set_dir(data_pin[i], GPIO_IN);
    }

  // 
} 

//------------------------------------------------------------------------------------------------------

void ArdDataPinsToOutput()
{
  // set Arduino data pins to output
  gpio_put(LS_DIR_PIN, 1);
  for (byte i = 0; i <= 7; i += 1)
    {
      gpio_set_dir(data_pin[i], GPIO_OUT);
    }

  delayShort();
}

//------------------------------------------------------------------------------------------------------

void packOutputAndSelect()
{
  // sets pack data pins to output and selects pack memory chip (EPROM or RAM)
  gpio_put(SLOT_SOE_PIN, 0);        // enable output - pack ready for read
  delayShort();                     // delay whilst pack data pins go to output
  
  gpio_put(SLOT_SS_PIN, 0);         // take memory chip CE_N low - select pack
  delayShort();
  delayShort();
}

//------------------------------------------------------------------------------------------------------

void packDeselectAndInput()
{
  //  printf("\nDeselect 0");
  
  // deselects pack memory chip and sets pack pins to input
  gpio_put(SLOT_SS_PIN, 1); // take memory chip select high - deselect pack
  delayShort();
  gpio_put(SLOT_SOE_PIN, 1); // disable output - pack ready for write
  delayShort(); // don't do anything until output disabled & pack data pins become input
  delayShort();

  //printf("\nDeselect 1\n");
}

//------------------------------------------------------------------------------------------------------

byte readByte()
{
  // Reads Arduino data pins, assumes pins are in the input state

  byte data = 0;
  
  for (int8_t i = 7; i >= 0; i -= 1)
    {
      // int8 type to allow -ve 8 bit numbers, so loop can end at -1
      // read each pin and shift pin values into data, starting at MSB
      
      data = (data << 1) + gpio_get(data_pin[i]); 
    }
  
  return data;
}

//------------------------------------------------------------------------------------------------------

void writeByte(byte data)
{
  // Writes to Arduino data pins, assumes pins are in the output state

  for (byte i = 0; i <= 7; i += 1)
    {
      gpio_put(data_pin[i], data & 1);    // write data bits to data_pin[i], starting at LSB 
      data = data >> 1;                   // shift data right, so can AND with 1 to read next bit
    }
}

//------------------------------------------------------------------------------------------------------

void resetAddrCounter()
{
  // Resets pack counters

  gpio_put(SLOT_SCLK_PIN, 0);          // start with clock low, CLK is LSB of address
  delayShort();
  
  CLK_val = 0;                         // set CLK state low

  gpio_put(SLOT_SMR_PIN, 1);           // reset address counter - asynchronous, doesn't require SLOT_SS_PIN or OE_N
  delayShort();

  gpio_put(SLOT_SMR_PIN, 0);
  delayShort();

  //delayLong();
  current_address = 0;
}

//------------------------------------------------------------------------------------------------------

void nextAddress()
{
  // toggles CLK to advance the address, CLK is LSB of address and triggers the counter
  if (CLK_val == 0)
    {
      gpio_put(SLOT_SCLK_PIN, 1);
      CLK_val = 1;
    }
  else if (CLK_val == 1)
    {
      gpio_put(SLOT_SCLK_PIN, 0);
      CLK_val = 0;
    }

  delayShort(); // settling time, let datapak catch up with address

  current_address++;

  if (paged_addr && ((current_address & 0xFF) == 0))
    {
      nextPage(); // if paged mode and low byte of addr is zero (end of page) - advance page counter
    }
}

//------------------------------------------------------------------------------------------------------

void nextPage()
{
  // pulses PGM low, -ve edge advance page counter
  if (program_low)
    {
      // if SLOT_SPGM_PIN low, pulse high then low
      gpio_put(SLOT_SPGM_PIN, 1);
      delayShort();
      gpio_put(SLOT_SPGM_PIN, 0);
      delayShort();
    }
  else
    {
      // if SLOT_SPGM_PIN high, pulse low then high
      gpio_put(SLOT_SPGM_PIN, 0); // -ve edge advances counter
      delayShort();
      gpio_put(SLOT_SPGM_PIN, 1);
      delayShort();
    }
}

//------------------------------------------------------------------------------------------------------

void setAddress(word addr)
{
  // resets counter then toggles counters to reach address, <word> so max address is 64k
  resetAddrCounter(); // reset counters
  byte page = (addr & 0xFF00) >> 8; // high byte of address
  byte addr_low = addr & 0xFF; // low byte of address
  if (paged_addr)
    { // if paged addressing
      for (byte p = 0; p < page; p++)
	{
	  nextPage();
	} // call nextPage, until page reached
    
      for (byte a = 0; a < addr_low; a++)
	{
	  nextAddress();
	} // call nextAddress, until addr_low reached  
    }
  else
    { // else linear addressing
      for (word a = 0; a < addr; a++)
	{
	  nextAddress();
	} // call nextAddress, until addr reached 
    }
  delayShort(); // extra delay, not needed?
  current_address = addr;
}

//------------------------------------------------------------------------------------------------------

void printPageContents(byte page)
{

  // set address to start of page and print contents of page (256 bytes) to serial (formatted with addresses)
  
  ArdDataPinsToInput(); // ensure Arduino data pins are set to input
  packOutputAndSelect(); // Enable pack data bus output, then select it
  resetAddrCounter(); // reset address counter
  
  printf("%s\n", "addr  00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F  -------TEXT-------");
  printf("%s\n", "------------------------------------------------------  01234567  89ABCDEF"); // comment out to save memory
  
  for (byte p = 0; p < page; p++)
    { // page counter
      if (paged_addr)
	{ // paged addressing
	  nextPage(); // call nextPage(), until page reached      
	}
      else
	{ // linear addressing
	  for (word a = 0; a <= 0xFF; a++)
	    {
	      nextAddress(); // call nextAddress() for every address in page, including 0xFF - so will advance to 0x100
	    }
	}
    }
  
  for (word base = 0; base <= 255; base += 16)
    {
      // loop through 0 to 255 in steps of 16, last step to 256

      byte data;
      char str[19] = ""; // fill with zeros, 16+2+1, +1 for char zero terminator

      str[8] = 32; str[9] = 32; // gap in middle, 2 spaces

      byte pos = 0;
      char buf[6]; // buffer for sprintf: 5 chars + terminator

      sprintf(buf, "%04x ", base + page * 0x100); // format page in hex

      printf(buf);

      for (byte offset = 0; offset <= 15; offset += 1)
	{
	  // loop through 0 to 15

	  if ((offset == 0) || (offset == 8))
	    {
	      printf(" "); // at 0 or 7 print an extra spaces
	    }
	
	  data = readByte(); // read byte from pack
	  sprintf(buf, "%02x ", data); // format data byte in hex
	  printf(buf);
      
	  if ((data > 31) && (data < 127))
	    {
	      // if printable char, put in str        
	      str[pos] = data;
	    }
	  else
	    {
	      str[pos] = '.'; // else use '.'
	    }
      
	  pos++;

	  if (pos == 8)
	    {
	      pos += 2; // jump 2 spaces after 8th char in str
	    }
      
	  nextAddress();
	}

      printf(" ");
      printf("%s\n", str);
    
      /*
	char buf[80]; // buffer for sprintf - used too much memory
	sprintf(buf, "%04x  %02x %02x %02x %02x %02x %02x %02x %02x  %02x %02x %02x %02x %02x %02x %02x %02x  %s",
	base + page * 0x100, data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7],
	data[8], data[9], data[10], data[11], data[12], data[13], data[14], data[15]);
	printf("%s\n", buf);*/
    }
  printf("\n");
  
  packDeselectAndInput(); // deselect pack, then set pack data bus to input
}

//------------------------------------------------------------------------------------------------------

byte readAddr(word addr, bool output) { // set address, read byte, print if output true, and return value

  ArdDataPinsToInput(); // ensure Arduino data pins are set to input
  packOutputAndSelect(); // Enable pack data bus output, then select it
  setAddress(addr);

  byte dat = readByte(); // read Arduino data bus
  
  if (output == true)
    {
      char buf[15];
      sprintf(buf, "(Ard) %04x  %02x", addr, dat); // print to buf with 3 digits hex, then 2 digits hex, with leading zeros
      printf("%s\n", buf);
    }
  
  packDeselectAndInput(); // deselect pack, then set pack data bus to input

  return dat;
}

////////////////////////////////////////////////////////////////////////////////

void printPackMode()
{
  if (datapak_mode)
    {
      printf("\n(Ard) Now in Datapak mode (Arduino input pullups)"); // sets Arduino input pullups for datapack mode in ArdDataPinsToInput()
    }
  
  else
    {
      printf("\n(Ard) Now in Rampak mode (No Arduino input pullups)"); // no Arduino input pullups
    }
}

void printAddrMode()
{
  if (paged_addr)
    {
      printf("(Ard) Now in paged addressing mode");
    }
  else
    {
      printf("(Ard) Now in linear addressing mode");
    }
}
void printCommands()
{
  printf("\n(Ard) datapak_read_write_v1.3\n");
  printPackMode();
  printAddrMode();
  printf("\n(Ard) Select a command:\ne - erase\nr - read pack\nw - write pack");
  printf("\n0 - print page 0\n1 - print page 1\n2 - print page 2\n3 - print page 3");
  printf("\nt - write TEST record to main\nm - rampak (or datapak) mode\nl - linear (or paged) addressing");
  printf("\ni - print pack id byte flags\nd - directory and size pack\nb - check if pack is blank");
  printf("\n? - list commands\nx - exit");
}

////////////////////////////////////////////////////////////////////////////////
//
// read all pack data, output if selected and return address of 1st free byte (with value 0xFF)
// output: 0 - none, 1 - print address & byte value, 2 - send bytes
//
////////////////////////////////////////////////////////////////////////////////

word readAll(byte output)
{
  word endAddr = read_dir(); // size pack - max is 64k

  printf("\nSize: %08X", endAddr);

  ArdDataPinsToInput();          // ensure Arduino data pins are set to input
  packOutputAndSelect();         // Enable pack data bus output then select it
  resetAddrCounter();            // reset counters

  if (output == 2)
    {
      // tell PC to read data
#if 0      
      printfln("XXRead"); // send "XXRead" to PC to tell it to receive read data
      Serial.write(0); // size bytes, highest is zero, so max is 64k
      Serial.write(highByte(endAddr));
      Serial.write(endAddr & 0xFF);
#endif
    }  
  
  bool quit = false;
  word addr_tot = 0; // total
  
  while  (quit == false)
    {
      byte dat = readByte(); // read Datapak byte at current address
      
      if (output == 1)
	{
	  // print to serial
	  byte addr_low = addr_tot & 0xFF;
	  printf("\n(Ard) %04x: %02x", addr_low, dat); 
	}

#if 0
      if (output == 2)
	{
	  // send to serial as bytes

	  Serial.write(dat); // send byte only
	  unsigned long t = millis();

	  while (!(Serial.available() > 0))
	    {
	      // wait for data echo back, if no data: loop until there is, or timeout

	      if (millis()-t > 1000)
		{                                      // if timeout
		  printf("\n(Ard) Timeout!");
		  return false;
		}
	    }                                          // end of while loop delay for data echo back from PC

	  byte datr = Serial.read(); // read byte value from serial

	  if (datr != dat)
	    {
	      // if echo datr doesn't match dat sent

	      delay(600);                        // delay to force timeout on PC !!
	      
	      printf("\n(Ard) Read data not verified by PC!");
	      return false;        
	    }
	}
#endif
      
      if (addr_tot >= endAddr)
	{
	  quit = true;
	}
      
      if ((read_fixed_size == true) && (addr_tot >= read_pack_size))
	{
	  quit = true;                 // quit if reach packSize and readFixedsize is true
	}
      
    if (addr_tot >= 0xFF)
      {
	quit = true; // break loop if reach max size: (65536-1 bytes) 64k !!
      }
    
    if (quit != true)
      {      
	nextAddress();
	addr_tot++;
      }
    }
  
  packDeselectAndInput();       // deselect pack, then set pack data bus to input
  return addr_tot;              // returns end address
}

//------------------------------------------------------------------------------------------------------

bool writePakByteRampak(byte val) { // writes val to current address, returns true if written ok - no longer used

  packDeselectAndInput(); // deselect pack, then set pack data bus to input (OE_N = high)
  ArdDataPinsToOutput(); // set Arduino data pins to output - can't do this with Datapak also output! OE_N must be high
  
  writeByte(val); // put value on Arduino data bus

  delayShort();

  gpio_put(SLOT_SS_PIN, 0); // take CE_N low - select
  delayShort(); // delay for write
  gpio_put(SLOT_SS_PIN, 1); // take CE_N high - deselect
  delayShort(); 

  ArdDataPinsToInput(); // set Arduino data pins to input
  packOutputAndSelect(); // Enable pack data bus output then select it
  byte dat = readByte(); // read byte from datapak
  packDeselectAndInput(); // deselect pack, then set pack data bus to input

  printf("\n %02X %02X", dat, val);
  
  if (dat == val)
    {
      return true; // true if value written ok
    }
  else
    {
      return false; // false if write cannot be verified
    }
}

//------------------------------------------------------------------------------------------------------

bool writePakByte(byte val, bool output)

{
  // writes val to current address, returns false if write failed
  // returns no. of cycles if write ok
  // needs both SLOT_SPGM_PIN low and CE_N low for Eprom write
  
  byte write_cycles = 1;
  byte dat = 0;
  byte i = 1;
  
  if (datapak_mode)
    {
      write_cycles = max_datapak_write_cycles;
    }
  
  for (i = 1; i <= write_cycles; i++)
    {
      
      packDeselectAndInput(); // deselect pack, then set pack data bus to input (CE_N high, OE_N high)
      
      if (datapak_mode)
	{
	  if (output)
	    {
	      printf("\n(Ard) Datapak write VPP on");
	    }
	  
	  gpio_put(VPP_ON_PIN, 1); // turn on VPP, 5V VCC is on already
	  delayLong();      
	}
      else
	{
	  delayShort();
	}
  
      ArdDataPinsToOutput();       // set Arduino data pins to output - can't do this with Datapak also output! OE_N must be high
      
      writeByte(val);              // put value on Arduino data bus
      
      if (datapak_mode)
	{
	  delayLong();
	}
      else
	{
	  delayShort();
	}
      
      gpio_put(SLOT_SS_PIN, 0); // take CE_N low - select
      
      if (datapak_mode)
	{
	  sleep_us(datapak_write_pulse);
	  //loop_delay(datapak_write_pulse); // delay for write
	}
      else
	{
	  delayShort();
	}
      
      gpio_put(SLOT_SS_PIN, 1); // take CE_N high - deselect
      if (datapak_mode)
	{
	  delayLong();
	}
      else
	{
	  delayShort();
	}
      
    if (datapak_mode)
      {
	gpio_put(VPP_ON_PIN, 0); // turn off VPP, 5V VCC goes off later
	delayLong();
	if (output)
	  {
	    printf("\n(Ard) Datapak write VPP off");
	  }
      }
  
    ArdDataPinsToInput();         // set Arduino data pins to input - for read    
    packOutputAndSelect();        // Enable pack data bus output then select it
  
    dat = readByte();             // read byte from datapak
  
    if (output)
      {
	printf("(Ard) Cycle: %02d, Write: %02x, Read: %02x", i, val, dat);
      }
    
    if ((!force_write_cycles) && (dat == val))
      {
	break; // written ok, so break out of for-loop
      }
    }
  
  packDeselectAndInput(); // deselect pack, then set pack data bus to input (CE_N high, OE_N high)

  if ((overwrite) == true && (dat == val) && (datapak_mode))
    {
      // for non-CMOS EPROM write again to make sure - overwrite
      if (output)
	{
	  printf("\n(Ard) Datapak write VPP on");
	}
      
    gpio_put(VPP_ON_PIN, 1); // turn on VPP, 5V VCC is on already
    delayLong();

    ArdDataPinsToOutput(); // set Arduino data pins to output - can't do this with Datapak also output! OE_N must be high

    writeByte(val); // put value on Arduino data bus
    delayLong();  

    gpio_put(SLOT_SS_PIN, 0); // take CE_N low - select
    sleep_us(datapak_write_pulse*3);
    //loop_delay(datapak_write_pulse*3); // 3*delay for overwrite

    gpio_put(SLOT_SS_PIN, 1); // take CE_N high - deselect
    delayLong();  

    gpio_put(VPP_ON_PIN, 0); // turn off VPP, 5V VCC goes off later
    delayLong();

    if (output)
      {
	printf("(Ard) Datapak write VPP off");
      }
  }
  
  if (dat == val)
    {
    return i;              // return no. of cycles if value written ok
    }
  else
    {
      return false;        // false if write cannot be verified
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// Compares an OPK file from the SD card to the currently attached datapak
//
////////////////////////////////////////////////////////////////////////////////

void compare_opk_file(I2C_SLAVE_DESC *slave, char *filename)
{
  bool done_w = false;
  int addr = 0;
  char line[200];
  int datr = 0;
  
  // Mount SD card
  // Files are in PAK directory (like the pak-gadget)
  
  mount_sd();
  
  if( cd_to_pak_dir(slave) )
    {
      unmount_sd();
      return;
    }

  oled_clear_display(slave);
  oled_set_xy(slave, 0, 0);
  sprintf(line, "Reading file");
  oled_display_string(slave, line);
  
  oled_set_xy(slave, 0, 8);
  sprintf(line, "%s", filename);
  oled_display_string(slave, line);

  loop_delay(3000000);
  
  // Open file
  FIL fil;
  FRESULT fr = f_open(&fil, filename, FA_READ);
  
  if (FR_OK != fr)
    {
      sprintf(line, "Failed to open:");
      oled_clear_display(slave);
      oled_set_xy(slave, 0, 0);
      oled_display_string(slave, line);
      
      oled_set_xy(slave, 0, 7);
      sprintf(line, "%s", filename);
      oled_display_string(slave, line);

      loop_delay(3000000);
      unmount_sd();
      return;
    }

  char opk_header[6];
  char buf[100];
  int pak_i = 0;
  int br = 0;
  bool done = false;
  char name[80];
  char extension[20];
  bool modify_header = false;
  int numBytes = 0;
  
  // If the extension is .opk then read the header and get the file size
  if( sscanf(filename, "%[^.].%s", name, extension) == 2 )
    {
      if( strcmp(extension, "opk") == 0 )
	{
	  // Read header to get pack size
	  f_read(&fil, opk_header, sizeof(opk_header), &br);

	  numBytes = opk_header[3]*256*256+opk_header[4]*256+opk_header[5];

	  printf("\nOPK file data block length = 0x%06X (%d) bytes", numBytes, numBytes);
	  loop_delay(3000000);
	}
    }

  if (datapak_mode)
    {
      gpio_put(SLOT_SPGM_PIN, 0); // take SLOT_SPGM_PIN low - select & program - need SLOT_SPGM_PIN low for CE_N low if OE_N high
      program_low = true;
    }

  resetAddrCounter(); // reset address counters, after SLOT_SPGM_PIN low

  // Compare the data
  // Assume the datapack data is the same as the SD file data
  bool data_identical = true;
  
  for (addr = 0; addr <= numBytes;)
    {
      printf("\naddr:%d", addr);
      
      // Bytes from file
      f_read(&fil, buf, sizeof buf, &br);

      printf("\nbr=%d", br);

      if( br==0 )
	{
	  break;
	}
      
      // Compare bytes
      for(int j=0; j<br; j++)
	{
	  // Byte from SD card
	  datr = readByte();
	  
	  // Check byte
	  if( j==50 )
	    {
	      printf("\n%d %d", buf[j], datr);
	    }
	  
	  if( buf[j] != datr )
	    {
	      // Not the same, we have our answer...
	      data_identical = false;
	      addr = numBytes+1;
	      break;
	    }
	  
	  addr++;
	  nextAddress();
	}
    }
  
  f_close(&fil);
  
  oled_set_xy(slave, 0, 16);
  oled_printf(&oled0, "%d bytes read", numBytes);
  
  if (datapak_mode)
    {
      gpio_put(SLOT_SPGM_PIN, 1); // take SLOT_SPGM_PIN high
      program_low = false;
    }
  
  if( data_identical )
    {
      oled_set_xy(slave, 0, 24);
      oled_printf(&oled0, "Data is identical");
      printf("\nData is identical\n");
    }
  else
    {
      oled_set_xy(slave, 0, 24);
      oled_printf(&oled0, "Data not identical", numBytes);
      printf("\nData not identical\n");
    }
  
  unmount_sd();

  return;
}

////////////////////////////////////////////////////////////////////////////////
//
// Writes an OPK file from the SD card to the currently attached datapak
//
////////////////////////////////////////////////////////////////////////////////

void write_opk_file(I2C_SLAVE_DESC *slave, char *filename)
{
  // write PC serial data to pack
  bool done_w = false;
  word addr = 0;
  char line[200];
  
  // Mount SD card
  // Files are in PAK directory (like the pak-gadget)
  
  mount_sd();
  
  if( cd_to_pak_dir(slave) )
    {
      unmount_sd();
      return;
    }

  oled_clear_display(slave);
  oled_set_xy(slave, 0, 0);
  sprintf(line, "Reading file");
  oled_display_string(slave, line);
  
  oled_set_xy(slave, 0, 8);
  sprintf(line, "%s", filename);
  oled_display_string(slave, line);

  loop_delay(3000000);
  
  // Read the file from the SD card into the pak memory
  FIL fil;
  FRESULT fr = f_open(&fil, filename, FA_READ);
  
  if (FR_OK != fr)
    {
      sprintf(line, "Failed to open:");
      oled_clear_display(slave);
      oled_set_xy(slave, 0, 0);
      oled_display_string(slave, line);
      
      oled_set_xy(slave, 0, 7);
      sprintf(line, "%s", filename);
      oled_display_string(slave, line);

      loop_delay(3000000);
      unmount_sd();
      return;
    }

  char opk_header[6];
  char buf[1];
  int pak_i = 0;
  int br = 0;
  bool done = false;
  char name[80];
  char extension[20];
  bool modify_header = false;
  int numBytes = 0;
  
  // If the extension is .opk then we drop the first 6 bytes
  if( sscanf(filename, "%[^.].%s", name, extension) == 2 )
    {
      if( strcmp(extension, "opk") == 0 )
	{
	  // Read header to get pack size
	  f_read(&fil, opk_header, sizeof(opk_header), &br);

	  numBytes = opk_header[3]*256*256+opk_header[4]*256+opk_header[5];
	  printf("\nOPK file data block length = 0x%06X (%d) bytes", numBytes, numBytes);
	}
    }

  if (datapak_mode)
    {
      gpio_put(SLOT_SPGM_PIN, 0); // take SLOT_SPGM_PIN low - select & program - need SLOT_SPGM_PIN low for CE_N low if OE_N high
      program_low = true;
    }

  resetAddrCounter(); // reset address counters, after SLOT_SPGM_PIN low

  // Write the data

  for (addr = 0; addr <= numBytes; addr++)
    {
      f_read(&fil, buf, sizeof buf, &br);
      
      if( br == 0 )
	{
	  // File is too short, exit
	  printf("\nFile too short.");
	  break;
	}
      
      done_w = writePakByte(buf[0], false);
      if (done_w == false)
	{
	  printf("\n(Ard) Write byte failed!");
	  break;
	}
      nextAddress();
    }
  
  f_close(&fil);
  
  oled_set_xy(slave, 0, 16);
  sprintf(line, "%d bytes read", numBytes);
  oled_display_string(slave, line);
  
  if (datapak_mode)
    {
      gpio_put(SLOT_SPGM_PIN, 1); // take SLOT_SPGM_PIN high
      program_low = false;
    }
  
  if (done_w == true)
    {
      printf("\n(Ard) Write done ok");
    }
  
  unmount_sd();
}


////////////////////////////////////////////////////////////////////////////////
//
// Reads a datapack and writes the contents to an OPK file on the SD card
//
////////////////////////////////////////////////////////////////////////////////

void read_opk_file(I2C_SLAVE_DESC *slave, char *filename)
{
  bool done_w = false;
  word addr = 0;
  char line[200];
  
  // Mount SD card
  // Files are in PAK directory (like the pak-gadget)

  printf("\nReading datapack to SD card file...");
  
  mount_sd();
  
  if( cd_to_pak_dir(slave) )
    {
      unmount_sd();
      return;
    }

  oled_clear_display(slave);
  oled_set_xy(slave, 0, 0);
  oled_printf(&oled0, "Writing file");
  
  oled_set_xy(slave, 0, 8);
  oled_printf(&oled0, "%s", filename);

  loop_delay(3000000);
  
  // Write the data to the file
  FIL fil;
  FRESULT fr = f_open(&fil, filename, FA_CREATE_NEW | FA_WRITE);
  
  if (FR_OK != fr)
    {
      printf("\nFailed to open file '%s'", filename);
      oled_clear_display(slave);
      oled_set_xy(slave, 0, 0);
      oled_printf(&oled0, "Failed to open:");
      
      oled_set_xy(slave, 0, 7);
      oled_printf(&oled0, "%s", filename);

      loop_delay(3000000);
      unmount_sd();
      return;
    }

  printf("\nOpened file '%s'", filename);
  
  char opk_header[6];
  char buf[1];
  int pak_i = 0;
  int br = 0;
  bool done = false;
  char name[80];
  char extension[20];
  bool modify_header = false;
  int numBytes = 0;

  // Write an OPK file header.
  
  // If the extension is .opk then we drop the first 6 bytes
  numBytes = 32*1024;

  opk_header[0] = 'O';
  opk_header[1] = 'P';
  opk_header[2] = 'K';
  opk_header[3] = (numBytes >> 16) & 0xff;
  opk_header[4] = (numBytes >>  8) & 0xff;
  opk_header[5] = (numBytes >>  0) & 0xff;
  
  f_write(&fil, opk_header, sizeof(opk_header), &br);

  printf("\nOPK file header = %d %d %d %d %d %d",
	 opk_header[0],
	 opk_header[1],
	 opk_header[2],
	 opk_header[3],
	 opk_header[4],
	 opk_header[5]);
	 
  printf("\nDatapack length = 0x%06X (%d) bytes", numBytes, numBytes);

  ArdDataPinsToInput(); // ensure Arduino data pins are set to input
  packOutputAndSelect(); // Enable pack data bus output, then select it
  resetAddrCounter(); // reset address counters, after SLOT_SPGM_PIN low

  // Write the data

  for (addr = 0; addr <= numBytes; addr++)
    {
      // Read a byte at a time
      buf[0] = readByte();
      f_write(&fil, buf, sizeof buf, &br);
      
      if( br == 0 )
	{
	  // File is too short, exit
	  printf("\nwrite error");
	  break;
	}
      nextAddress();
    }
  
  f_close(&fil);
  
  oled_set_xy(slave, 0, 16);
  oled_printf(&oled0, "%d bytes read", addr);
  loop_delay(3000000);
  
  unmount_sd();
}


//------------------------------------------------------------------------------------------------------

bool writePakSerial(word numBytes)
{
  // write PC serial data to pack
    bool done_w = false;

#if 0
  word addr = 0;
  
  if (datapak_mode)
    {
      gpio_put(SLOT_SPGM_PIN, 0); // take SLOT_SPGM_PIN low - select & program - need SLOT_SPGM_PIN low for CE_N low if OE_N high
      program_low = true;
    }
  
  resetAddrCounter(); // reset address counters, after SLOT_SPGM_PIN low
  
  for (addr = 0; addr <= numBytes; addr++)
    {
      unsigned long t = millis();

      while (!(Serial.available() > 0))
	{ // if no data from PC, loop until there is, or timeout
	  if (millis()-t > 1000)
	    {
	      // if timeout
	      printf("\n(Ard) Timeout!");
	      return false;
	    }
	}

    byte datw = Serial.read(); // read byte value from serial
    
    Serial.write(datw); // write data back to PC to verify and control data flow
    done_w = writePakByte(datw, /* output */ false); // write value to current memory address, no output because PC needs to verify data
    
    if (done_w == false)
      {
	printf("\n(Ard) Write byte failed!");
	break;
      }
    nextAddress();
    }
  
  if (datapak_mode)
    {
      gpio_put(SLOT_SPGM_PIN, 1); // take SLOT_SPGM_PIN high
      program_low = false;
    }
  
  if (done_w == true)
    {
      printf("\n(Ard) Write done ok");
    }

#endif
  return done_w;
}

//------------------------------------------------------------------------------------------------------

void eraseBytes(word addr, word numBytes)
{
  // erase numBytes, starting at addr - ony for rampaks

  setAddress(addr);

  bool done_ok = false;
  byte addr_low = addr & 0xFF;

  printf("(Ard) Erasing:");

  for (word i = 0; i <= numBytes; i++)
    {
      // loop through numBytes to write
      done_ok = writePakByte(0xFF, false /* no output */); // write 0xFF
      
      if (done_ok == false)
	{
	  printf("\n(Ard) Erase failed!");
	  break; // break out of for loop
	}
      
      if (addr_low == 0xFF)
	{
	  // if end of page reached, go to next page, addr_low will wrap around to zero
	  printf("."); // "." printed for each end of page
	}
      
      nextAddress(); 
      addr_low++;  
    }
  
  if (done_ok == true)
    {
      printf("\n");
      printf("\n(Ard) Erased ok");
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// write record to main
//
////////////////////////////////////////////////////////////////////////////////

void WriteMainRec(bool output)
{
  word endAddr = read_dir();

  printf("\nPack size (from dir) is: %08X", endAddr);

  if (datapak_mode)
    {
      gpio_put(SLOT_SPGM_PIN, 0); // take SLOT_SPGM_PIN low - select & program - need SLOT_SPGM_PIN low for CE_N low if OE_N high
      program_low = true;
    }

  if (readAddr(endAddr, /* output */ true) == 0xFF)
    {
      // move to start address & read it, if value is 0xFF write record

      char main[] = "--The quick brown fox jumps over the lazy dog.";     // Main record text with leading "--" for length & identifier bytes
      byte len_main = sizeof(main)-1;                                     // not including 0 at end
      
      main[0] = len_main-2;      // record text length identifier byte
      main[1] = 0x90;            // MAIN file identifier byte

      bool done_ok = false;
      int8_t cycles = 0;         // can be -ve if write failed
      
      for (byte i = 0; i < len_main; i++)
	{
	  // index starts from 0, so do while i < len_str, not i <= len_str
	  char chr = main[i];
	  
	  cycles = writePakByte(chr, /* output */ true);             // write i'th char of main record, cycles is no. of write cycles for EPROM
	  
	  if (cycles > 0)
	    {
	      done_ok = true;
	    }
	  
	  if (output)
	    {
	      printf("(Ard) %04x: %02d %02x %c", i, cycles, chr, chr);
	    }    

	  // if (((endAddr & 0xFF) == 0xFF) & (paged_addr == true)) nextPage(); // if end of page reached, and paged_addr mode is true, go to next page - moved to nextAddress()
	  nextAddress(); // next address
	  endAddr++; // increment address pointer

	  if (done_ok == false)
	    {
	    break;
	    }
	}
      
      if (datapak_mode)
	{
	  gpio_put(SLOT_SPGM_PIN, 1); // take SLOT_SPGM_PIN high
	  program_low = false;
	}
      
      if (done_ok == true)
	{
	  printf("\n(Ard) add record done successfully");
	}
      
      else
	{
	  printf("\n(Ard) add record failed!");
	}
    }
  else
    {
      printf("\n(Ard) no 0xFF byte to add record!");
    }
}

//------------------------------------------------------------------------------------------------------
// pack sizing and id bytes - code originally from Matt Callow, but modified. https://github.com/mattcallow/psion_pak_reader
//------------------------------------------------------------------------------------------------------

byte read_next_byte()
{
  // only used by Matt's code
  nextAddress();
  byte data = readByte();

  return data;
}

void incr_addr(uint16_t bytes) { // only used by Matt's code
  for (uint16_t i=0;i<bytes;i++) { // increase address while i < bytes
    nextAddress();
  }
}

////////////////////////////////////////////////////////////////////////////////
//
// Writes a test data pattern to the first few bytes of the pack
//

char test_data[] = "**Test data***01234567890===ABCDEFGHIJKLMNOPQRSTUVWXYZ--The second large piece of test text---(000000000000)(111111111111111111)(2222222222222222222222222222222222222222222222222222222222222222222222)";

void write_test_data(void)
{
  int addr;
  int done_w;
  
  if (datapak_mode)
    {
      gpio_put(SLOT_SPGM_PIN, 0); // take SLOT_SPGM_PIN low - select & program -
                                  // need SLOT_SPGM_PIN low for CE_N low if OE_N high
      program_low = true;
    }

  resetAddrCounter(); // reset address counters, after SLOT_SPGM_PIN low

  printf("\nWriting test data");
  
  for (addr = 0; addr <= strlen(test_data); addr++)
    {
      printf("\nByte %d", addr);
      
      if( datapak_mode)
	{
	  done_w = writePakByte(test_data[addr], false);
	}
      else
	{
	  done_w = writePakByteRampak(test_data[addr]);
	}
      
      if (done_w == false)
	{
	  printf("\nWrite byte failed!");
	  break;
	}
      nextAddress();
    }
  
  if (datapak_mode)
    {
      gpio_put(SLOT_SPGM_PIN, 1); // take SLOT_SPGM_PIN high
      program_low = false;
    }

  packDeselectAndInput(); // deselect pack, then set pack data bus to input
  printf("\nDone");
}

// Checks the data in the datapack against the test data

void check_test_data(void)
{
  int addr;
  int done_w;
  int data;

  ArdDataPinsToInput(); // ensure Arduino data pins are set to input
  packOutputAndSelect(); // Enable pack data bus output, then select it

  if (datapak_mode)
    {
      gpio_put(SLOT_SPGM_PIN, 0); // take SLOT_SPGM_PIN low - select & program -
                                  // need SLOT_SPGM_PIN low for CE_N low if OE_N high
      program_low = true;
    }
  
  resetAddrCounter(); // reset address counters, after SLOT_SPGM_PIN low

  printf("\nChecking test data\n");
  
  for (addr = 0; addr <= strlen(test_data); addr++)
    {
      data = readByte(); // read byte from pack
      printf("%c", (data==test_data[addr])?'.':'x');

      nextAddress();
    }
  
  if (datapak_mode)
    {
      gpio_put(SLOT_SPGM_PIN, 1); // take SLOT_SPGM_PIN high
      program_low = false;
    }

  packDeselectAndInput(); // deselect pack, then set pack data bus to input
  printf("\nDone\n");
}


void print_pak_id()
{
  // the first 2 bytes on a pack are the id and size bytes. id gives info about the pack

  ArdDataPinsToInput();              // ensure Arduino data pins are set to input
  packOutputAndSelect();             // Enable pack data bus output, then select it
  resetAddrCounter();

  byte id = readByte();
  byte sz = read_next_byte();
  byte pack_size = sz * 8;

  packDeselectAndInput();            // deselect pack, then set pack data bus to input
  printf("\n");
  printf("Id Flags: %02X", id);
  
  // print bit flag value using conditional operator: (condition) ? true : false

  printf("\n0: ");    printf((id & 0x01)? "invalid"             : "valid"); 
  printf("\n1: ");    printf((id & 0x02)? "datapak"             : "rampak");
  printf("\n2: ");    printf((id & 0x04)? "paged"               : "linear");
  printf("\n3: ");    printf((id & 0x08)? "not write protected" : "write protected");
  printf("\n4: ");    printf((id & 0x10)? "non-bootable"        : "bootable");
  printf("\n5: ");    printf((id & 0x20)? "copyable"            : "copy protected");
  printf("\n6: ");    printf((id & 0x40)? "standard"            : "flashpak or debug RAM pak");
  printf("\n7: ");    printf((id & 0x80)? "MK1"                 : "MK2");

  printf("\nSize: "); printf("%d", pack_size); printf(" kB");
}

void button_pak_id(struct MENU_ELEMENT *e)
{
  // the first 2 bytes on a pack are the id and size bytes. id gives info about the pack

  ArdDataPinsToInput();              // ensure Arduino data pins are set to input
  packOutputAndSelect();             // Enable pack data bus output, then select it
  resetAddrCounter();

  byte id = readByte();
  byte sz = read_next_byte();
  byte pack_size = sz * 8;

  packDeselectAndInput();            // deselect pack, then set pack data bus to input

  oled_clear_display(&oled0);
  
  // print bit flag value using conditional operator: (condition) ? true : false

  oled_set_xy(&oled0, 0, 0);
  oled_printf(&oled0, "0: ");    oled_printf(&oled0, (id & 0x01)? "invalid"             : "valid");
  oled_set_xy(&oled0, 64, 0);
  oled_printf(&oled0, "1: ");    oled_printf(&oled0, (id & 0x02)? "datapak"             : "rampak");
  oled_set_xy(&oled0, 0,  8);
  oled_printf(&oled0, "2: ");    oled_printf(&oled0, (id & 0x04)? "paged"               : "linear");
  oled_set_xy(&oled0, 0, 16);
  oled_printf(&oled0, "3: ");    oled_printf(&oled0, (id & 0x08)? "not write protected" : "write protected");
  oled_set_xy(&oled0, 0, 24);
  oled_printf(&oled0, "4: ");    oled_printf(&oled0, (id & 0x10)? "non-bootable"        : "bootable");
  oled_set_xy(&oled0, 0, 32);
  oled_printf(&oled0, "5: ");    oled_printf(&oled0, (id & 0x20)? "copyable"            : "copy protected");
  oled_set_xy(&oled0, 0, 40);
  oled_printf(&oled0, "6: ");    oled_printf(&oled0, (id & 0x40)? "standard"            : "flash/dbg RAM");
  oled_set_xy(&oled0, 0, 48);
  oled_printf(&oled0, "7: ");    oled_printf(&oled0, (id & 0x80)? "MK1"                 : "MK2");
}

void button_pak_hdr(struct MENU_ELEMENT *e)
{
  // the first 2 bytes on a pack are the id and size bytes. id gives info about the pack

  ArdDataPinsToInput();              // ensure Arduino data pins are set to input
  packOutputAndSelect();             // Enable pack data bus output, then select it
  resetAddrCounter();

  byte id = readByte();
  byte sz = read_next_byte();
  byte pack_size = sz * 8;

  packDeselectAndInput();            // deselect pack, then set pack data bus to input

  oled_clear_display(&oled0);

  oled_set_xy(&oled0, 0, 0);
  oled_printf(&oled0, "Id Flags: %02X", id);
  
  oled_set_xy(&oled0, 0, 8);
  oled_printf(&oled0, "Size: "); oled_printf(&oled0, "%d", pack_size); printf(" kB");
}

word read_dir(void)
{
  // read filenames and size pack
  ArdDataPinsToInput(); // ensure Arduino data pins are set to input
  packOutputAndSelect(); // Enable pack data bus output, then select it
  resetAddrCounter();
  
  uint8_t id = 0; // datafile id
  
  printf("\n");
  
  printf("\nADDR     TYPE           NAME        ID        Del? SIZE");
  
  incr_addr(9); // move past header to 10th byte
  
  while(current_address < max_eprom_size)
    {
      printf("\n0x%06X ", current_address+1);
      
      char short_record[10] = "         ";    // 9 spaces + terminator
      uint8_t rec_len = read_next_byte();
      
      if (rec_len == 0xff)
	{
	  printf("\nEnd of pack");
	  break;
	}
      
      uint16_t jump = rec_len; // for jump, reduces when bytes read
      uint16_t rec_size = rec_len; // for printing
      uint8_t rec_type = read_next_byte();
      
      if (rec_type == 0x80)
	{
	  jump = (read_next_byte()<<8) + read_next_byte();
	  
	  printf("Long record, length = 0x%08X", jump);
	} 
      else
	{
	  if (rec_len > 9)
	    {
	      rec_len = 9; // read first 8 chars of short record for printing
	    }
	  
	  for (uint8_t i=0;i<=rec_len-1;i++)
	    {
	      short_record[i] = read_next_byte();
	      jump--;
	    }
	  
	  printf("0x%04X", rec_type); // print rec type (4 chars)
	  
	  switch (rec_type & 0x7f)
	    {
	      // print type (9 chars)
	      
	    case 0x01:
	      printf(" [Data]  ");
	      break;
	    case 0x02:
	      printf(" [Diary] ");
	      break;
	    case 0x03:
	      printf(" [OPL]   ");
	      break;
	    case 0x04:
	      printf(" [Comms] ");
	      
	      break;
	    case 0x05:
	      printf(" [Sheet] ");
	      break;
	    case 0x06:
	      printf(" [Pager] ");
	      break;
	    case 0x07:
	      printf(" [Notes] ");
	      break;
	    case 0x10 ... 0x7E :
	      printf(" [Rec]   ");// datafile record
	      break;
	    default:
	      printf(" [misc]  ");// unknown type
	    }

	  for(int i=0; i<strlen(short_record); i++)
	    {
	      if( short_record[i] == 9 )
		{
		  short_record[i] = ' ';
		}
	    }
	  
          printf("%-10s", short_record);

	  // isn't 1 <= 7?
	  
          if ( ((rec_type & 0x7f) == 1) ||
	       ((rec_type & 0x7f) <= 7))
	    {
	      // filename, with id in last byte
	      id = short_record[8];
	      printf("  0x%06X ", id); // id (6 chars + 1 space)
	    }
          else
	    {
	      printf("           ");
	    }
	  
          printf(" %-3s  ", (rec_type < 0x80) ? "Yes" : "No"); // deleted y/n? (6 chars)
          printf("0x%06X ", rec_size); // length (6 chars)
	}
      
      incr_addr(jump);
    }
  
  packDeselectAndInput(); // deselect pack, then set pack data bus to input
  
  return current_address;
}

bool blank_check()
{
  ArdDataPinsToInput(); // ensure Arduino data pins are set to input
  packOutputAndSelect(); // Enable pack data bus output, then select it
  resetAddrCounter();
  
  printf("\nBlank Check in 1k chunks '.'-blank 'x'-not blank\n");

  bool blank = (readByte() == 0xff); // is 1st byte blank?
  bool blank_1k = blank; // is this 1k blank?

  //for (uint16_t i=1;(blank && (i <= max_eprom_size));i++) { // read bytes while blank or up to max_eprom_size
  
  for (int i=1;i <= max_eprom_size;i++)
    {
      // read bytes up to max_eprom_size 

      if (read_next_byte() != 0xff)
	{
	  // blank true if byte is 0xFF
	  blank = false;
	  blank_1k = false;
	}
      
      if ((i % 1024) == 0)
	{
	  // every 1024 bytes print a dot (addr div 1024)
	  // dot if blank, x if not, using conditional operator: (condition) ? true : false
	  
	  printf(blank_1k ? "." : "x"); 
	  blank_1k = true; // reset blank for next 1k chunk
	}
    }
  
  printf("\nIs pack blank? : ");
  printf(blank ? "Yes" : "No");
  printf("\n");
  packDeselectAndInput();               // deselect pack, then set pack data bus to input

  return blank;
}


void button_blank(struct MENU_ELEMENT *e)
{
  ArdDataPinsToInput(); // ensure Arduino data pins are set to input
  packOutputAndSelect(); // Enable pack data bus output, then select it
  resetAddrCounter();

  oled_clear_display(&oled0);
  oled_set_xy(&oled0, 0, 0);
  oled_printf(&oled0, "Blank Check");

  bool blank = (readByte() == 0xff); // is 1st byte blank?
  bool blank_1k = blank; // is this 1k blank?

  //for (uint16_t i=1;(blank && (i <= max_eprom_size));i++) { // read bytes while blank or up to max_eprom_size
  
  for (int i=1;i <= max_eprom_size;i++)
    {
      // read bytes up to max_eprom_size 

      if (read_next_byte() != 0xff)
	{
	  // blank true if byte is 0xFF
	  blank = false;
	  blank_1k = false;
	}
      
      if ((i % 1024) == 0)
	{
	  // every 1024 bytes print a dot (addr div 1024)
	  // dot if blank, x if not, using conditional operator: (condition) ? true : false
	  
	  printf(blank_1k ? "." : "x"); 
	  blank_1k = true; // reset blank for next 1k chunk
	}
    }
  
  oled_set_xy(&oled0, 0, 8);
  oled_printf(&oled0, "%s", blank ? "Blank" : "Not blank");

  packDeselectAndInput();               // deselect pack, then set pack data bus to input
}

////////////////////////////////////////////////////////////////////////////////
//
// Serial over USB main loop 
//
////////////////////////////////////////////////////////////////////////////////

void wait_serial_key(void)
{
  int ch;
  do
    {
      ch = getchar_timeout_us(100);
    }
  while (ch == PICO_ERROR_TIMEOUT);
}

void take_high(int gpio, char *gpio_name)
{
#if 0
  gpio_init(gpio);
  gpio_set_dir(gpio, GPIO_OUT);
#endif
  
  printf("\nGPIO %s high (%d)", gpio_name, gpio);
  gpio_put(gpio, 1);

  // Wait for key
  wait_serial_key();

  printf("\nGPIO %s low\n", gpio_name);
  gpio_put(gpio, 0);
}


void serial_loop()
{
  int  key;
  
  if( (key = getchar_timeout_us(1000)) != PICO_ERROR_TIMEOUT)
    {
      printf("\nkey %d", key);
      
      //char buf[15];
      //sprintf(buf, "(Ard) In: 0x%02x", byte(key)); // print input character
      //printf(buf);
      
      switch (key)
	{
	case '-':
#if 1	  
	  ArdDataPinsToOutput();
#endif
	  gpio_set_dir(SLOT_SD0_PIN, GPIO_OUT);
#if 0
	  gpio_set_dir(LS_DIR_PIN, GPIO_OUT);
	  gpio_put(LS_DIR_PIN, 1);
#endif	  

	  gpio_put(SLOT_SS_PIN, 0);
	  gpio_put(SLOT_SOE_PIN, 0);
	  gpio_put(SLOT_SPGM_PIN, 0);
	  gpio_put(SLOT_SMR_PIN, 0);
	  gpio_put(SLOT_SCLK_PIN, 0);
	  gpio_put(SLOT_SD0_PIN, 0);
	  gpio_put(SLOT_SD1_PIN, 0);
	  gpio_put(SLOT_SD2_PIN, 0);
	  gpio_put(SLOT_SD3_PIN, 0);
	  gpio_put(SLOT_SD4_PIN, 0);
	  gpio_put(SLOT_SD5_PIN, 0);
	  gpio_put(SLOT_SD6_PIN, 0);
	  gpio_put(SLOT_SD7_PIN, 0);
	  
	  take_high(SLOT_SS_PIN, "SS");
	  take_high(SLOT_SOE_PIN, "SOE");
	  take_high(SLOT_SMR_PIN, "SMR");
	  take_high(SLOT_SPGM_PIN, "SPGM");
	  take_high(SLOT_SCLK_PIN, "SCLK");
	  take_high(SLOT_SD0_PIN, "SD0");
	  take_high(SLOT_SD1_PIN, "SD1");
	  take_high(SLOT_SD2_PIN, "SD2");
	  take_high(SLOT_SD3_PIN, "SD3");
	  take_high(SLOT_SD4_PIN, "SD4");
	  take_high(SLOT_SD5_PIN, "SD5");
	  take_high(SLOT_SD6_PIN, "SD6");
	  take_high(SLOT_SD7_PIN, "SD7");
	  ArdDataPinsToInput();
	  break;
	  
	  // Debug test option
	case '=':
#if 1	  
	  ArdDataPinsToInput();          // ensure Arduino data pins are set to input
	  packOutputAndSelect();         // Enable pack data bus output then select it
	  resetAddrCounter();            // reset counters

	  gpio_put(VPP_ON_PIN, 0);
	    
	  gpio_put(SLOT_SMR_PIN, 1);           // reset address counter - asynchronous, doesn't require SLOT_SS_PIN or OE_N
	  loop_delay(100000);
	  
	  gpio_put(SLOT_SMR_PIN, 0);

	  loop_delay(100000);
	  gpio_put(SLOT_SOE_PIN, 0);
	  gpio_put(SLOT_SPGM_PIN, 1);
	  gpio_put(SLOT_SS_PIN, 0);
	  delayShort();
	  
	  for(int j=0; j<10; j++)
	    {
	      //byte dat = readByte(); // read Datapak byte at current address
#if 0
	      nextAddress();
#else
	      gpio_put(SLOT_SCLK_PIN, 1);
	      gpio_put(SLOT_SCLK_PIN, 0);

#endif

	      for(int i=0; i<8; i++)
		{
		  printf("\ndata line %d = %d", i, gpio_get(data_gpio[i]));
		}
	      
	      //printf("\nData byte:%02X\n", dat);
	    }
	  printf("\n");


#endif
	  break;
	  
	case 'e' : { // erase bytes
	  if (!datapak_mode)
	    {
	      // 512 bytes for first 2 pages
	      printf("\n(Ard) Erase 512 bytes:");
	      
	      // starting from 0, erase bytes
	      eraseBytes(0,512); 
	    }
	  else
	    {
	      printf("\n(Ard) Can't erase a Datapak! Use UV lamp, or a Rampak");
	    }
	  break;
	}
	  
	case 'w' :
	  {
	    // This needs converting to C from Arduino library code.
	    // write pack from PC data
	    bool write_ok = false;
	    
	    printf("\n(Ard) Write Serial data to pack");
	    
	    // Check for "XXWrite" from PC to indicate following data is write data
	    char str[200] = "XXWrite";
	    
	    if( 0 /* Wait for XXWrite */)
	      {
		// waits for "XXWrite" to signal start of data, or until timeout
		
		byte numBytes[2] = {0};                             // byte array to store pack image size
		//		byte bytes_read = Serial.readBytes(numBytes,2);     // read 2 bytes for pack size, will need to be 3 if pack > 64kB !

		if (/*bytes_read == 2*/ 0)
		  {
		    word numBytesTotal = (numBytes[0] << 8) + numBytes[1];   // shift 1st byte 8 bits left for high byte and add 2nd byte as low byte

		    write_ok = writePakSerial(numBytesTotal);                // write numBytes from file

		    char buf[30];
		    sprintf(buf, "(Ard) Pack size to write was: %04x bytes", numBytesTotal);
		    printf(buf); 
		  }
		else
		  {
		    printf("(Ard) Wrong no. of size bytes sent!");
		  }
	      }
	    else
	      {
		printf("(Ard) No XXWrite to begin data");
	      }
	  
	    if (write_ok == false)
	      {
		printf("(Ard) Write failed!");
	      }
	    break;
	  } 
	
	case 'r' :
	  {
	    // read pack and send to PC
	  
	    // 0 - no output, 1 - print data, 2 - dump data to serial
	    word endAddr = readAll(1); 
	    char buf[30];

	    // end address is same as size as address starts from 0, size starts from 1
	    printf("\n(Ard) Size of pack is: 0x%04x bytes\n", endAddr); 
	    break;
	  }
	  
	case '0':
	  { // read page 0
	    printf("(Ard) Page 0:");
	    printPageContents(0);              // print zero page - first 256 bytes of datapak
	    break;
	  }
      
	case '1':
	  { // read page 1
	    printf("(Ard) Page 1:");
	    printPageContents(1);                // print page 1 - second 256 bytes of datapak
	    break;
	  }
	  
	case '2':
	  { // read page 2
	    printf("(Ard) Page 2:");
	    printPageContents(2); // print page 2 - third 256 bytes of datapak
	    break;
	  }
	  
	case '3':
	  { // read page 3
	    printf("(Ard) Page 3:");
	    printPageContents(3); // print page 3 - fourth 256 bytes of datapak
	    break;
	  }

	case 'u':
	  write_test_data();
	  break;

	case 'v':
	  check_test_data();
	  break;
	  
	case 't':
	  { // add test record to main
	    printf("(Ard) add record to Main");
	    WriteMainRec(true /*true for output */); // add a record to main
	    break;
	  }
	  
	case 'm':
	  {// toggle between datapak and rampak modes
	    datapak_mode = 1-datapak_mode; // toggle datapak mode
	    printPackMode();
	    break;
	  }
	  
	case 'l':
	  {// toggle between paged and linear addressing modes
	    paged_addr = 1-paged_addr; // toggle addressing mode
	    printAddrMode();
	    break;
	  }
	  
	case 'i':
	  {// read pack id byte and print flag values
	    print_pak_id();
	    break;
	  }
	  
	case 'd':
	  {
	    // read dir and size pack

	    word pack_size = read_dir();

	    printf("\nPack size is: %08X", pack_size);
	    break;
	  }
	  
	case 'b':
	  {// check if pack is blank
	    blank_check();
	    break;
	  }

	case 'h':
	case '?':
	  {
	    // add test record to main
	    printCommands();
	    break;
	  }

	case 'z':
	  auto_size(false);
	  break;
	  
	case 'x':
	  {
	    // x to exit
	    
	    // exit - set all control lines to input - pack will set default line states
	    gpio_set_dir(SLOT_SS_PIN,  GPIO_IN); // deselect first
	    gpio_set_dir(SLOT_SOE_PIN,  GPIO_IN);
	    gpio_set_dir(SLOT_SPGM_PIN, GPIO_IN);
	    gpio_set_dir(SLOT_SCLK_PIN, GPIO_IN);
	    gpio_set_dir(SLOT_SMR_PIN, GPIO_IN);
	    
	    ArdDataPinsToInput();
	    
	    printf("\n(Ard) Please Remove Rampak/Datapak");
	    printf("XXExit"); // send exit command to PC
	    
	    do
	      {
		// tight_loop?
		loop_delay(1000);
	      }
	    while (true);
	    
	    break;
	  }
	  
	default:
	  {
	    printf("\n(Ard) Command not recognised!");
	    break;
	  }
	}    
    }
  else
    {
      stdio_flush();
      printf(" \b");
    }
}

////////////////////////////////////////////////////////////////////////////////

// read the value on the data bus

BYTE get_data_bus(void)
{
  int data = 0;

  // As we are reading the bus, the direction line should be high
  gpio_put(LS_DIR_PIN, 0);
  
#if DIRECT_GPIO
  // Direct register access, as it's faster
  data = sio_hw->gpio_in;
  data >>= 0;
  data &= 0xff;
  
#else
  int i;
  
  for(i=0; i<8; i++)
    {
      if( gpio_get(data_gpio[i]) )
	{
	  data |= (1<<i);
	}
    }
#endif
  return((BYTE)data);
  
}

// Set the data bus to point to the Psion, i.e. outputs from us
void set_bus_outputs(void)
{
  return;
  // Drive level shifters to be driving Psion

  gpio_put(LS_DIR_PIN, 1);

#if DIRECT_GPIO
#if 0
  sio_hw->gpio_oe |= 0x000000FF;
#else
  sio_hw->gpio_oe_set = 0x000000FF;
#endif
#else
  int i;
  
  
  for(i=0; i<8; i++)
    {
      gpio_set_dir(data_gpio[i], GPIO_OUT);
    }
#endif
}

// Set data bus to drive us
void set_bus_inputs(void)
{
  return;
#if DIRECT_GPIO
  
  // Direct register access to make things faster

  // Get current output states
#if 0
  sio_hw->gpio_oe &= 0xffffff00;
#else
  sio_hw->gpio_oe_clr = 0x000000FF;
#endif
#else
  int i;
  
  for(i=0; i<8; i++)
    {
      gpio_set_dir(data_gpio[i], GPIO_IN);
    }
#endif
  // Drive level shifters to be driving Pico
  
  gpio_put(LS_DIR_PIN, 0);

}

// Set up the data bus GPIO lines

void set_data_bus(BYTE data)
{
  return;
#if DIRECT_GPIO
  int states;
  int dat = data & 0xff;
  //dat = ss_address;
  
  // Direct register access to make things faster
#if 0
  // Get current output states
  states = sio_hw->gpio_out;

  // Our data has its LSB at GPIO8
  states &= 0xFFFFFF00;
  sio_hw->gpio_out = states | (dat <<0);
#else
  sio_hw->gpio_set = (  dat  << 0);
  sio_hw->gpio_clr = ((dat ^ 0xFF) << 0);
    
#endif
  
#else
  int i;

  // Ensure the level shifters are towards the Psion, and we are set as ouputs
  for(i=0; i<8; i++)
    {
      if( data & (1 << i) )
	{
	  gpio_put(data_gpio[i], 1);
	}
      else
	{
	  gpio_put(data_gpio[i], 0);
	}
    }
#endif
}

////////////////////////////////////////////////////////////////////////////////
//
// Poll and handle the address counter on the second core
//

void handle_address(void)
{
  int last_ss;
  int last_sclk;
  int last_soe;
  int last_smr;
  int last_spgm;
  
  last_ss     = gpio_get(SLOT_SS_PIN);
  last_sclk   = gpio_get(SLOT_SCLK_PIN);
  last_soe    = gpio_get(SLOT_SOE_PIN);
  last_smr    = gpio_get(SLOT_SMR_PIN);
  last_spgm   = gpio_get(SLOT_SPGM_PIN);

  int ss;
  int sclk;
  int soe;
  int smr;
  int spgm;

  TRACE1('I');
  TRACE1('N');
  TRACE1('I');
  TRACE1('T');

  while(1)
    {
      // Read GPIO states
      ss     = gpio_get(SLOT_SS_PIN);
      sclk   = gpio_get(SLOT_SCLK_PIN);
      soe    = gpio_get(SLOT_SOE_PIN);
      smr    = gpio_get(SLOT_SMR_PIN);
      spgm   = gpio_get(SLOT_SPGM_PIN);
      
      //----------------------------------------------------------------------
      // SCLK handling
      // The lower address bit is the CLK line
      // Falling edge
      if( (last_sclk == 1) && (sclk == 0))
	{
	  // Only increment if the SMR line is low
	  if( smr == 0 )
	    {
	      TRACE1('c');
	      ss_address+=2;
	      ss_address &= (~1);
	      
	      // Wrap address
#if 0	      
	      ss_address &= PAK_MEMORY_SIZE - 1;
#else
	      // Wrap address according to pack size and whether we are paged
	      if( pak_memory[0] & PACK_ID_PAGED )
		{
		  // Paged packs have address counter that wraps at 0x100
		  ss_address &= 0xFF;
		}
	      else
		{
		  ss_address &= PAK_MEMORY_SIZE - 1;
		}
#endif	      
	      TRACE1(ss_address & 0xFF);
	      TRACE1((ss_address >> 8) & 0xFF);
	    }
	  else
	    {
	      // Trace 'clock when SMR high', this is seen in traces
	      TRACE1('z');
	    }
	}
      
      // Rising edge
      if( (last_sclk == 0) && (sclk == 1))
	{
	  if( smr == 0 )
	    {
	      ss_address |= 1;
	      TRACE1('C');
	      TRACE1(ss_address & 0xFF);
	      TRACE1((ss_address >> 8) & 0xFF);
	    }
	  else
	    {
	      TRACE1('Z');
	    }
	}

      // We now have to present data if we are selected
      if( ss == 0 )
	{
	  // We are selected, look at SOE to see if we should drive the data bus or not
	  if ( soe )
	    {
	      int data;
	      
	      // High so don't drive the data bus, this is a write
	      // Capture data on bus
	      set_bus_inputs();
	      
	      // We don't write here as SS hasn't gone high and OE hasn't gone high
	      data = get_data_bus();

#if !READ_ONLY		  
	      if( smr == 0 )
		{
		  // write to ram
		  WRITE_TRAP;
		  pak_memory[PAK_ADDRESS] = data;
		}
#endif
	    }
	  else
	    {
	      // Low, so this is a read
	      // Is it a read of the pak ID?
	      if( smr && spgm )
		{
		  TRACE1('i');
		  
		  // ID byte
		  set_bus_outputs();
		  set_data_bus(1);
		}
	      else
		{
		  // Read of pak memory
		  set_bus_outputs();
		  set_data_bus(pak_memory[PAK_ADDRESS]);
		}
	    }
	  
	}

      //--------------------------------------------------------------------------------
      // Page Counter

      if( (last_spgm == 1) && (spgm == 0) )
	{
	  TRACE1('P');
	  ss_page += (1 << 8);
	  ss_page &= 0x00007F00;
	}
      
      //----------------------------------------------------------------------
      // SMR handling
      
      if( (last_smr == 0) && (smr == 1) )
	{
	  TRACE1('R');
	  TRACE1('E');
	  TRACE1('S');
	  
	  ss_address=0;
	  ss_page = 0;
	}

      last_ss     = ss;
      last_sclk   = sclk;
      last_soe    = soe;
      last_smr    = smr;
      last_spgm   = spgm;

    }
}

////////////////////////////////////////////////////////////////////////////////
//
// Main Loop
//
// Two itmes are serviced here, the menu for the OLED and the serial USB
// interface
//
////////////////////////////////////////////////////////////////////////////////


int main()
{
  char line[80];

  // Turn VPP off immediately
  gpio_init(VPP_ON_PIN);
  gpio_put(VPP_ON_PIN, 0);
  gpio_set_dir(VPP_ON_PIN, GPIO_OUT);

  // Set up default file name, default is angling pak
  strcpy(current_file, "angler.opk");
  
#if FF_FIRST_BYTES
  for(int k=0; k< 100; k++)
    {
      pak_memory[k] = 0xff;
    }
#endif

  stdio_init_all();
  loop_delay(2000000);

  printf("\n\nPsion Organiser Datapack Tool\n\n");
  printf("\nInitialising...");
  printf("\nSetting GPIOs...");
  
  // Select the SD card
  gpio_init(22);
  gpio_put(22, 0);
  gpio_set_dir(22, GPIO_OUT);
  gpio_put(22, 0);
  
  // Set up directions for the control lines
  gpio_init(SLOT_SS_PIN);
  gpio_init(SLOT_SCLK_PIN);
  gpio_init(SLOT_SMR_PIN);
  gpio_init(SLOT_SOE_PIN);
  gpio_init(SLOT_SPGM_PIN);

  for(int i=0; i<8; i++)
    {
      gpio_init(data_gpio[i]);
      gpio_set_dir(data_gpio[i], GPIO_IN);
    }
  
  gpio_set_dir(SLOT_SS_PIN, GPIO_OUT);
  gpio_set_dir(SLOT_SCLK_PIN, GPIO_OUT);
  gpio_set_dir(SLOT_SMR_PIN, GPIO_OUT);
  gpio_set_dir(SLOT_SOE_PIN, GPIO_OUT);
  gpio_set_dir(SLOT_SPGM_PIN, GPIO_OUT);

    // Drive data bus towards us
  gpio_init(LS_DIR_PIN);
  gpio_put(LS_DIR_PIN, 0);

  // LS_DIR is an output
  gpio_set_dir(LS_DIR_PIN, GPIO_OUT);

#if 0
  gpio_set_irq_enabled_with_callback(SLOT_SS_PIN,   GPIO_IRQ_EDGE_RISE | GPIO_IRQ_EDGE_FALL, true, &gpio_callback);
  gpio_set_irq_enabled_with_callback(SLOT_SCLK_PIN, GPIO_IRQ_EDGE_RISE | GPIO_IRQ_EDGE_FALL, true, &gpio_callback);
  gpio_set_irq_enabled_with_callback(SLOT_SMR_PIN,  GPIO_IRQ_EDGE_RISE | GPIO_IRQ_EDGE_FALL, true, &gpio_callback);
  gpio_set_irq_enabled_with_callback(SLOT_SOE_PIN,  GPIO_IRQ_EDGE_RISE | GPIO_IRQ_EDGE_FALL, true, &gpio_callback);
  gpio_set_irq_enabled_with_callback(SLOT_SPGM_PIN, GPIO_IRQ_EDGE_RISE | GPIO_IRQ_EDGE_FALL, true, &gpio_callback);
#endif

  printf("\nInitialising SD card driver...");

#define SD_CARD 1
  
#if SD_CARD  
  // Initialise SD card driver
  sd_init_driver();
#endif

#if 1
  printf("\nSetting up buttons...");
  
  // Set up button gpios
  for(int i=0; i<NUM_BUTTONS; i++)
    {
      gpio_init(but_pins[i]);
      gpio_set_dir(but_pins[i], GPIO_IN);

#if PICOPAK      
      // Set pull ups for buttons
      gpio_set_pulls(but_pins[i], 1, 0);
#endif
    }
#endif
  
  printf("\nSetting up OLED...");

#define OLED_ON 1
  
#if OLED_ON  
  // Set up OLED display
  i2c_init(&i2c_bus_0);
    
  oled_setup(&oled0);

  // Set up the OLED menu
  
  current_menu = (struct MENU_ELEMENT *)&(home_menu[0]);
  last_menu = (struct MENU_ELEMENT *)&(home_menu[0]);
  the_home_menu = last_menu;

  to_home_menu(NULL);

  init_buttons();
#endif
  
  int count = 0;

#if SD_CARD  
  // Read config file into memory buffer
  // That will tell us which file to load
  process_config_file(&oled0);
#endif
  
  // datapack tool main loop

  while(1)
    {

      stdio_flush();
#if OLED_ON
      // Overall loop, which contains the polling loop and the menu loop
      oled_clear_display(&oled0);
      
      oled_set_xy(&oled0, 0,0);
      oled_display_string(&oled0, "Datapak Gadget");
      
#if USE_INTERRUPTS
      oled_set_xy(&oled0, 0,14);
      oled_display_string(&oled0, "Interrupts");
#endif
      
      sprintf(line, "%s", current_file);
      oled_set_xy(&oled0, 0, 14);
      oled_display_string(&oled0, line);
#endif
      
#if SD_CARD      
      // Mount and unmount the SD card to set the sd_ok_flag up
      mount_sd();
      unmount_sd();
      
      oled_set_xy(&oled0, 0,21);
      if( sd_ok_flag )
	{
	  oled_display_string(&oled0, "SD card OK");
	  printf("\nSD card OK");
	}
      else
	{
	  oled_display_string(&oled0, "SD card NOT OK");
	  printf("\nSD card NOT OK");
	}

      loop_delay(1000000);
#endif
      
#if 1
      // Indicate we are now in menu
      oled_clear_display(&oled0);
      oled_set_xy(&oled0, 0,0);
      oled_display_string(&oled0, "Datapak Gadget Menu");
#endif

#if OLED_ON
      draw_menu(&oled0, current_menu, true);
#endif
      
      // Menu loop
      menuloop_done = 0;
      //stdio_flush();
      
      while(!menuloop_done)
	{
	  //	  printf("\nLoop0");
	  stdio_flush();
	  
#if OLED_ON
	  // Run menu
	  update_buttons();
#endif
	  
	  // Run serial interface
	  serial_loop();
	  //printf("\nLoop1\n");
	}
    }
}
  




